# Extended Covariant Script Generator
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Copyright (C) 2017-2021 Michael Lee(李登淳)
#
# Email:   lee@covariant.cn, mikecovlee@163.com
# Github:  https://github.com/mikecovlee
# Website: http://covscript.org.cn
#
# Generated by CovScript AST Visitor Generator

@require: 210503

package ecs_generator

namespace ecs_info
    constant version = "4.0.0 Cuon alpinus(Preview) Build 2"
    constant std_version = "210601"
end

import parsergen

struct lambda_type
    var capture_list = new array
    var argument_list = null
    var body_stmts = null
    var body_expr = null
end

struct catch_type
    var id = null
    var pos = {0, 0}
    var type = null
    var body = null
end

class generator
    var lambda_list = new array
    var file_name = new string
    var code_buff = new array
    var target = system.out
    var is_package = false
    var stack = new array
    var minmal = false
    var indent = -1
    function error(pos, text)
        var err = new parsergen.lex_error
        err.text = text
        err.pos = pos
        parsergen.print_error(file_name, code_buff, {err})
        system.exit(0)
    end
    function print_indent()
        if !minmal
            foreach i in range(indent) do target.print('\t')
        end
    end
    function visit_declaration(nodes)
        print_indent()
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "prep-stmt")
                matched = true
                # Recursive Visit prep-stmt
                this.visit_prep_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "namespace-stmt")
                matched = true
                # Recursive Visit namespace-stmt
                this.visit_namespace_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "var-stmt")
                matched = true
                # Recursive Visit var-stmt
                this.visit_var_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "using-stmt")
                matched = true
                # Recursive Visit using-stmt
                this.visit_using_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "function-stmt")
                matched = true
                # Recursive Visit function-stmt
                this.visit_function_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "class-stmt")
                matched = true
                # Recursive Visit class-stmt
                this.visit_class_stmt(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_module_list(nodes)
        var idx = 0
        # Visit id token
        target.print(nodes[idx++].data)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ".")
            # Visit term "."
            ++idx
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "*")
                    matched = true
                    # Visit term "*"
                    if !stack.empty() && stack.front == "import_wildcard"
                        stack.pop_front()
                    else
                        stack.push_front("import_wildcard")
                    end
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "module-list")
                    matched = true
                    target.print(".")
                    # Recursive Visit module-list
                    this.visit_module_list(nodes[idx++].nodes)
                end
                if !matched
                	# Error
                	return
                end
            end
        end
    end
    function visit_expr(nodes)
        var idx = 0
        # Recursive Visit single-expr
        this.visit_single_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
            # Visit term ","
            ++idx; target.print(", ")
            # Recursive Visit expr
            this.visit_expr(nodes[idx++].nodes)
        end
    end
    function visit_block_stmt(nodes)
        var idx = 0
        # Visit term "block"
        ++idx; target.print("block ")
        # Visit endl token
        ++idx; target.println("")
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
        # Visit term "end"
        print_indent()
        target.println("end")
    end
    function visit_endblock(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "end-stmt")
                matched = true
                # Recursive Visit end-stmt
                this.visit_end_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "else-stmt")
                matched = true
                # Recursive Visit else-stmt
                this.visit_else_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "until-stmt")
                matched = true
                # Recursive Visit until-stmt
                this.visit_until_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "catch-stmt")
                matched = true
                # Recursive Visit catch-stmt
                this.visit_catch_stmt(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_stmts(nodes)
        var idx = 0
        ++indent
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "statement")
            # Recursive Visit statement
            this.visit_statement(nodes[idx++].nodes)
            # Repeat
            while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "endl")
                # Visit endl token
                ++idx
            end
        end
        --indent
    end
    function visit_begin(nodes)
        var idx = 0
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
    end
    function visit_statement(nodes)
        print_indent()
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "prep-stmt")
                matched = true
                # Recursive Visit prep-stmt
                this.visit_prep_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "package-stmt")
                matched = true
                # Recursive Visit package-stmt
                this.visit_package_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "import-stmt")
                matched = true
                # Recursive Visit import-stmt
                this.visit_import_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "var-stmt")
                matched = true
                # Recursive Visit var-stmt
                this.visit_var_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "block-stmt")
                matched = true
                # Recursive Visit block-stmt
                this.visit_block_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "namespace-stmt")
                matched = true
                # Recursive Visit namespace-stmt
                this.visit_namespace_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "using-stmt")
                matched = true
                # Recursive Visit using-stmt
                this.visit_using_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "if-stmt")
                matched = true
                # Recursive Visit if-stmt
                this.visit_if_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "switch-stmt")
                matched = true
                # Recursive Visit switch-stmt
                this.visit_switch_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "while-stmt")
                matched = true
                # Recursive Visit while-stmt
                this.visit_while_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "loop-stmt")
                matched = true
                # Recursive Visit loop-stmt
                this.visit_loop_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "for-stmt")
                matched = true
                # Recursive Visit for-stmt
                this.visit_for_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "foreach-stmt")
                matched = true
                # Recursive Visit foreach-stmt
                this.visit_foreach_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "control-stmt")
                matched = true
                # Recursive Visit control-stmt
                this.visit_control_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "function-stmt")
                matched = true
                # Recursive Visit function-stmt
                this.visit_function_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "return-stmt")
                matched = true
                # Recursive Visit return-stmt
                this.visit_return_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "try-stmt")
                matched = true
                # Recursive Visit try-stmt
                this.visit_try_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "throw-stmt")
                matched = true
                # Recursive Visit throw-stmt
                this.visit_throw_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "class-stmt")
                matched = true
                # Recursive Visit class-stmt
                this.visit_class_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "expr-stmt")
                matched = true
                # Recursive Visit expr-stmt
                this.visit_expr_stmt(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_var_bind_list(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "id")
                matched = true
                # Visit id token
                target.print(nodes[idx++].data)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "...")
                matched = true
                # Visit ... token
                target.print(nodes[idx++].data)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "var-bind")
                matched = true
                # Recursive Visit var-bind
                this.visit_var_bind(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_for_stmt(nodes)
        var idx = 0
        # Visit term "for"
        ++idx; target.print("for ")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "var-def")
            # Recursive Visit var-def
            this.visit_var_def(nodes[idx++].nodes)
        end
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ";")
                matched = true
                # Visit term ";"
                ++idx; target.print(", ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
                matched = true
                # Visit term ","
                ++idx; target.print(", ")
            end
            if !matched
            	# Error
            	return
            end
        end
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "basic-expr")
            # Recursive Visit basic-expr
            this.visit_basic_expr(nodes[idx++].nodes)
        end
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ";")
                matched = true
                # Visit term ";"
                ++idx; target.print(", ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
                matched = true
                # Visit term ","
                ++idx; target.print(", ")
            end
            if !matched
            	# Error
            	return
            end
        end
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "basic-expr")
            # Recursive Visit basic-expr
            this.visit_basic_expr(nodes[idx++].nodes)
        end
        # Recursive Visit for-body
        this.visit_for_body(nodes[idx++].nodes)
    end
    function visit_for_body(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "do")
                matched = true
                # Visit term "do"
                ++idx; target.print(" do ")
                # Recursive Visit basic-expr
                this.visit_basic_expr(nodes[idx++].nodes)
                # Recursive Visit endline
                this.visit_endline(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "endl")
                matched = true
                # Visit endl token
                ++idx; target.println("")
                # Recursive Visit stmts
                this.visit_stmts(nodes[idx++].nodes)
                # Visit term "end"
                print_indent()
                target.println("end")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_class_stmt(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "class")
                matched = true
                # Visit term "class"
                ++idx; target.print("class ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "struct")
                matched = true
                # Visit term "struct"
                ++idx; target.print("struct ")
            end
            if !matched
            	# Error
            	return
            end
        end
        # Visit id token
        target.print(nodes[idx++].data)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "extends")
            # Visit term "extends"
            ++idx; target.print(" extends ")
            # Recursive Visit visit-expr
            this.visit_visit_expr(nodes[idx++].nodes)
        end
        # Visit endl token
        ++idx; target.println("")
        # Recursive Visit decl-stmts
        this.visit_decl_stmts(nodes[idx++].nodes)
        # Visit term "end"
        print_indent()
        target.println("end")
    end
    function visit_single_expr(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "lambda-expr")
                matched = true
                # Recursive Visit lambda-expr
                this.visit_lambda_expr(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "basic-expr")
                matched = true
                # Recursive Visit basic-expr
                this.visit_basic_expr(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_capture_list(nodes)
        var idx = 0
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "=")
            # Visit term "="
            ++idx
            stack.front.capture_list.push_back(nodes[idx].data : true)
        else
            stack.front.capture_list.push_back(nodes[idx].data : false)
        end
        # Visit id token
        ++idx
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
            # Visit term ","
            ++idx
            # Recursive Visit capture-list
            this.visit_capture_list(nodes[idx++].nodes)
        end
    end
    function visit_catch_stmt(nodes)
        var idx = 0
        # Visit term "catch"
        stack.front.pos = nodes.front.pos
        ++idx
        # Visit id token
        stack.front.id = nodes[idx++].data
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ":")
            # Visit term ":"
            ++idx
            # Recursive Visit visit-expr
            stack.front.type = nodes[idx++].nodes
            # this.visit_visit_expr(nodes[idx++].nodes)
        end
    end
    function visit_else_stmt(nodes)
        var idx = 0
        # Visit term "else"
        print_indent()
        ++idx; target.println("else")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "if")
            stack.push_front("elif")
            ++indent
            print_indent()
            # Visit term "if"
            ++idx; target.print("if ")
            # Recursive Visit basic-expr
            this.visit_basic_expr(nodes[idx++].nodes)
            # Visit endl token
            target.println("")
        end
    end
    function visit_unary_expr(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "unary-op")
                matched = true
                # Recursive Visit unary-op
                this.visit_unary_op(nodes[idx++].nodes)
                # Recursive Visit unary-expr
                this.visit_unary_expr(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "new" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "gcnew")
                # Optional
                if nodes.size > 2 && (typeid nodes[2] == typeid parsergen.syntax_tree && nodes[2].root == "array")
                    matched = true
                    # Condition
                    block
                        var matched = false
                        if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "new")
                            matched = true
                            # Visit term "new"
                            ++idx; target.print("ecs.param_new(")
                        end
                        if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "gcnew")
                            matched = true
                            # Visit term "gcnew"
                            ++idx; target.print("ecs.param_gcnew(")
                        end
                        if !matched
                            # Error
                            return
                        end
                    end
                    # Recursive Visit unary-expr
                    this.visit_unary_expr(nodes[idx++].nodes)
                    target.print(", ")
                    # Recursive Visit array
                    this.visit_array(nodes[idx++].nodes)
                    target.print(")")
                else
                    matched = true
                    # Condition
                    block
                        var matched = false
                        if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "new")
                            matched = true
                            # Visit term "new"
                            ++idx; target.print("new ")
                        end
                        if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "gcnew")
                            matched = true
                            # Visit term "gcnew"
                            ++idx; target.print("gcnew ")
                        end
                        if !matched
                            # Error
                            return
                        end
                    end
                    # Recursive Visit unary-expr
                    this.visit_unary_expr(nodes[idx++].nodes)
                end
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "prim-expr")
                matched = true
                # Recursive Visit prim-expr
                this.visit_prim_expr(nodes[idx++].nodes)
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "postfix-expr")
                    # Recursive Visit postfix-expr
                    this.visit_postfix_expr(nodes[idx++].nodes)
                end
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_constant(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "num")
                matched = true
                # Visit num token
                target.print(nodes[idx++].data)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "null")
                matched = true
                # Visit term "null"
                ++idx; target.print("null")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "true")
                matched = true
                # Visit term "true"
                ++idx; target.print("true")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "false")
                matched = true
                # Visit term "false"
                ++idx; target.print("false")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_var_bind(nodes)
        var idx = 0
        # Visit term "("
        ++idx; target.print("(")
        # Recursive Visit var-bind-list
        this.visit_var_bind_list(nodes[idx++].nodes)
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
            # Visit term ","
            ++idx; target.print(", ")
            # Recursive Visit var-bind-list
            this.visit_var_bind_list(nodes[idx++].nodes)
        end
        # Visit term ")"
        ++idx; target.print(")")
    end
    function visit_postfix_expr(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "++")
                matched = true
                # Visit term "++"
                ++idx; target.print("++")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "--")
                matched = true
                # Visit term "--"
                ++idx; target.print("--")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "...")
                matched = true
                # Visit term "..."
                ++idx; target.print("...")
            end
            if !matched
            	# Error
            	return
            end
        end
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "postfix-expr")
            # Recursive Visit postfix-expr
            this.visit_postfix_expr(nodes[idx++].nodes)
        end
    end
    function visit_lambda_expr(nodes)
        var idx = 0
        stack.push_front(new lambda_type)
        # Visit term "["
        ++idx
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "capture-list")
            # Recursive Visit capture-list
            this.visit_capture_list(nodes[idx++].nodes)
        end
        # Visit term "]"
        ++idx
        stack.push_front("function")
        # Visit term "("
        ++idx
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "argument-list")
            # Recursive Visit argument-list
            this.visit_argument_list(nodes[idx++].nodes, false)
        end
        # Visit term ")"
        ++idx
        var arg_list = new array
        while typeid stack.front != typeid string || stack.front != "function"
            arg_list.push_front(stack.front.first : stack.front.second)
            stack.pop_front()
        end
        stack.pop_front()
        stack.front.argument_list := arg_list
        # Recursive Visit lambda-body
        this.visit_lambda_body(nodes[idx++].nodes)
        lambda_list.push_back(stack.front)
        target.print("ecs.init_lambda(global.__ecs_lambda_impl_" + lambda_list.size + "__")
        var capture_str = ", "
        foreach it in stack.front.capture_list
            capture_str += it.first + ", "
        end
        capture_str.cut(2)
        target.print(capture_str + ")")
        stack.pop_front()
    end
    function visit_relat_expr(nodes)
        var idx = 0
        # Recursive Visit add-expr
        this.visit_add_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ">" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "<" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ">=" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "<=")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ">")
                    matched = true
                    # Visit term ">"
                    ++idx; target.print(" > ")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "<")
                    matched = true
                    # Visit term "<"
                    ++idx; target.print(" < ")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ">=")
                    matched = true
                    # Visit term ">="
                    ++idx; target.print(" >= ")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "<=")
                    matched = true
                    # Visit term "<="
                    ++idx; target.print(" <= ")
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit relat-expr
            this.visit_relat_expr(nodes[idx++].nodes)
        end
    end
    function visit_import_stmt(nodes)
        var idx = 0
        # Visit term "import"
        ++idx
        # Recursive Visit import-list
        this.visit_import_list(nodes[idx++].nodes)
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_asi_op(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "=")
                matched = true
                # Visit term "="
                ++idx; target.print(" = ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ":=")
                matched = true
                # Visit term ":="
                ++idx; target.print(" := ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "+=")
                matched = true
                # Visit term "+="
                ++idx; target.print(" += ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "-=")
                matched = true
                # Visit term "-="
                ++idx; target.print(" -= ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "*=")
                matched = true
                # Visit term "*="
                ++idx; target.print(" *= ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "/=")
                matched = true
                # Visit term "/="
                ++idx; target.print(" /= ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "%=")
                matched = true
                # Visit term "%="
                ++idx; target.print(" %= ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "^=")
                matched = true
                # Visit term "^="
                ++idx; target.print(" ^= ")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_lambda_body(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "{")
                matched = true
                # Visit term "{"
                ++idx
                # Repeat
                while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "statement")
                    if stack.front.body_stmts == null
                        stack.front.body_stmts = new array
                    end
                    # Recursive Visit statement
                    stack.front.body_stmts.push_back(nodes[idx++].nodes)
                    # this.visit_statement(nodes[idx++].nodes)
                    # Repeat
                    while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "endl")
                        # Visit endl token
                        ++idx
                    end
                end
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "->")
                matched = true
                # Visit term "->"
                ++idx
                # Recursive Visit cond-expr
                stack.front.body_expr = nodes[idx++].nodes
                # this.visit_cond_expr(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_prep_stmt(nodes)
        # Visit prep token
        link prep = nodes.front.data
        if prep != "@begin" && prep != "@end"
            var cmd = prep.split({':'})
            if cmd.size == 2
                if cmd[0] == "@require"
                    var require_ver = new string
                    foreach ch in cmd[1]
                        if !ch.isspace()
                            require_ver += ch
                        end
                    end
                    if require_ver <= ecs_info.std_version
                        target.println("@require: 210503")
                        return
                    else
                        error(nodes.front.pos, "Newer Language Standard required: " + require_ver + ", now on " + ecs_info.std_version)
                    end
                end
            end
            target.println(prep)
        end
    end
    function visit_argument_list(nodes, print)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "...")
                matched = true
                # Visit term "..."
                ++idx
                if print
                    target.print("...")
                else
                    stack.push_front(nodes[idx].data : {"vargs" : null}.to_hash_map())
                end
                # Visit id token
                if print
                    target.print(nodes[idx++].data)
                end
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "=" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "id")
                matched = true
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "=")
                    stack.push_front(nodes[++idx].data : {"pass-by-value" : null}.to_hash_map())
                    # Visit term "="
                    # target.print("=")
                else
                    stack.push_front(nodes[idx].data : new hash_map)
                end
                # Visit id token
                if print
                    target.print(nodes[idx++].data)
                else
                    ++idx
                end
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ":")
                    # Visit term ":"
                    ++idx
                    # Recursive Visit visit-expr
                    stack.front.second.insert("check-type", nodes[idx++].nodes)
                    # this.visit_visit_expr(nodes[idx++].nodes)
                end
                # Repeat
                while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
                    # Visit term ","
                    ++idx
                    if print
                        target.print(", ")
                    end
                    # Recursive Visit argument-list
                    this.visit_argument_list(nodes[idx++].nodes, print)
                end
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_visit_expr(nodes)
        var idx = 0
        # Recursive Visit object
        this.visit_object(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "->" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ".")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "->")
                    matched = true
                    # Visit term "->"
                    ++idx; target.print("->")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ".")
                    matched = true
                    # Visit term "."
                    ++idx; target.print(".")
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit visit-expr
            this.visit_visit_expr(nodes[idx++].nodes)
        end
    end
    function visit_basic_expr(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "var-bind")
                matched = true
                # Recursive Visit var-bind
                this.visit_var_bind(nodes[idx++].nodes)
                # Visit term "="
                ++idx; target.print(" = ")
                # Recursive Visit cond-expr
                this.visit_cond_expr(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "cond-expr")
                matched = true
                # Recursive Visit cond-expr
                this.visit_cond_expr(nodes[idx++].nodes)
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "asi-op")
                    # Recursive Visit asi-op
                    this.visit_asi_op(nodes[idx++].nodes)
                    # Recursive Visit single-expr
                    this.visit_single_expr(nodes[idx++].nodes)
                end
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_mul_expr(nodes)
        var idx = 0
        # Recursive Visit unary-expr
        this.visit_unary_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "*" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "/" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "%" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "^")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "*")
                    matched = true
                    # Visit term "*"
                    ++idx; target.print("*")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "/")
                    matched = true
                    # Visit term "/"
                    ++idx; target.print("/")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "%")
                    matched = true
                    # Visit term "%"
                    ++idx; target.print("%")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "^")
                    matched = true
                    # Visit term "^"
                    ++idx; target.print("^")
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit mul-expr
            this.visit_mul_expr(nodes[idx++].nodes)
        end
    end
    function visit_switch_stmts(nodes)
        var idx = 0
        ++indent
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "switch-case" || typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "switch-default")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "switch-case")
                    matched = true
                    # Recursive Visit switch-case
                    this.visit_switch_case(nodes[idx++].nodes)
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "switch-default")
                    matched = true
                    # Recursive Visit switch-default
                    this.visit_switch_default(nodes[idx++].nodes)
                end
                if !matched
                	# Error
                	return
                end
            end
            # Repeat
            while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "endl")
                # Visit endl token
                ++idx
            end
        end
        --indent
    end
    function visit_index(nodes)
        var idx = 0
        # Visit term "["
        ++idx; target.print("[")
        # Recursive Visit basic-expr
        this.visit_basic_expr(nodes[idx++].nodes)
        # Visit term "]"
        ++idx; target.print("]")
    end
    function visit_var_list(nodes)
        var idx = 0
        # Visit id token
        target.print(nodes[idx++].data)
        # Visit term "="
        ++idx; target.print(" = ")
        # Recursive Visit single-expr
        this.visit_single_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
            # Visit term ","
            ++idx; target.print(", ")
            # Recursive Visit var-list
            this.visit_var_list(nodes[idx++].nodes)
        end
    end
    function visit_if_stmt(nodes)
        var idx = 0
        stack.push_front("if")
        # Visit term "if"
        ++idx; target.print("if ")
        # Recursive Visit basic-expr
        this.visit_basic_expr(nodes[idx++].nodes)
        # Visit endl token
        ++idx; target.println("")
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "else-stmt")
            # Recursive Visit else-stmt
            this.visit_else_stmt(nodes[idx++].nodes)
            # Recursive Visit stmts
            this.visit_stmts(nodes[idx++].nodes)
        end
        while !stack.empty() && stack.front == "elif"
            stack.pop_front()
            print_indent()
            target.println("end")
            --indent
        end
        stack.pop_front()
        # Visit term "end"
        print_indent()
        target.println("end")
    end
    function visit_switch_case(nodes)
        var idx = 0
        # Visit term "case"
        print_indent()
        ++idx; target.print("case ")
        # Recursive Visit logic-or-expr
        this.visit_logic_or_expr(nodes[idx++].nodes)
        # Visit endl token
        ++idx; target.println("")
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
        # Visit term "end"
        print_indent()
        target.println("end")
    end
    function visit_foreach_stmt(nodes)
        var idx = 0
        # Visit term "foreach"
        ++idx; target.print("foreach ")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "id")
            # Visit id token
            target.print(nodes[idx++].data + " ")
        end
        # Visit term "in"
        ++idx; target.print("in ")
        # Recursive Visit basic-expr
        this.visit_basic_expr(nodes[idx++].nodes)
        # Recursive Visit for-body
        this.visit_for_body(nodes[idx++].nodes)
    end
    function visit_var_stmt(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "var")
                matched = true
                # Visit term "var"
                ++idx; target.print("var ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "link")
                matched = true
                # Visit term "link"
                ++idx; target.print("link ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "constant")
                matched = true
                # Visit term "constant"
                ++idx; target.print("constant ")
            end
            if !matched
            	# Error
            	return
            end
        end
        # Recursive Visit var-def
        this.visit_var_def(nodes[idx++].nodes)
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_object(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "array")
                matched = true
                # Recursive Visit array
                this.visit_array(nodes[idx++].nodes)
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "index")
                    # Recursive Visit index
                    this.visit_index(nodes[idx++].nodes)
                end
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "str")
                matched = true
                # Visit str token
                target.print(nodes[idx++].data)
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "index")
                    # Recursive Visit index
                    this.visit_index(nodes[idx++].nodes)
                end
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "local")
                matched = true
                # Visit term "local"
                ++idx; target.print("local")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "global")
                matched = true
                # Visit term "global"
                ++idx; target.print("global")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "element")
                matched = true
                # Recursive Visit element
                this.visit_element(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "char")
                matched = true
                # Visit char token
                target.print(nodes[idx++].data)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_using_stmt(nodes)
        var idx = 0
        # Visit term "using"
        ++idx; target.print("using ")
        # Recursive Visit using-list
        this.visit_using_list(nodes[idx++].nodes)
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_add_expr(nodes)
        var idx = 0
        # Recursive Visit mul-expr
        this.visit_mul_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "+" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "-")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "+")
                    matched = true
                    # Visit term "+"
                    ++idx; target.print(" + ")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "-")
                    matched = true
                    # Visit term "-"
                    ++idx; target.print(" - ")
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit add-expr
            this.visit_add_expr(nodes[idx++].nodes)
        end
    end
    function visit_prim_expr(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "visit-expr")
                matched = true
                # Recursive Visit visit-expr
                this.visit_visit_expr(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "constant")
                matched = true
                # Recursive Visit constant
                this.visit_constant(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_return_stmt(nodes)
        var idx = 0
        # Visit term "return"
        ++idx; target.print("return")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "expr")
            target.print(" ")
            # Recursive Visit expr
            this.visit_expr(nodes[idx++].nodes)
        end
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_while_stmt(nodes)
        var idx = 0
        # Visit term "while"
        ++idx; target.print("while ")
        # Recursive Visit basic-expr
        this.visit_basic_expr(nodes[idx++].nodes)
        # Visit endl token
        ++idx; target.println("")
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
        # Visit term "end"
        print_indent()
        target.println("end")
    end
    function visit_switch_stmt(nodes)
        var idx = 0
        # Visit term "switch"
        ++idx; target.print("switch ")
        # Recursive Visit basic-expr
        this.visit_basic_expr(nodes[idx++].nodes)
        # Visit endl token
        ++idx; target.println("")
        # Recursive Visit switch-stmts
        this.visit_switch_stmts(nodes[idx++].nodes)
        # Visit term "end"
        print_indent()
        target.println("end")
    end
    function visit_element(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "id")
                matched = true
                # Visit id token
                target.print(nodes[idx++].data)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "(")
                matched = true
                # Visit term "("
                ++idx; target.print("(")
                # Recursive Visit single-expr
                this.visit_single_expr(nodes[idx++].nodes)
                # Visit term ")"
                ++idx; target.print(")")
            end
            if !matched
            	# Error
            	return
            end
        end
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "fcall" || typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "index")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "fcall")
                    matched = true
                    # Recursive Visit fcall
                    this.visit_fcall(nodes[idx++].nodes)
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "index")
                    matched = true
                    # Recursive Visit index
                    this.visit_index(nodes[idx++].nodes)
                end
                if !matched
                	# Error
                	return
                end
            end
        end
    end
    function visit_namespace_stmt(nodes)
        var idx = 0
        # Visit term "namespace"
        ++idx; target.print("namespace ")
        # Visit id token
        target.print(nodes[idx++].data)
        # Visit endl token
        ++idx; target.println("")
        # Recursive Visit decl-stmts
        this.visit_decl_stmts(nodes[idx++].nodes)
        # Visit term "end"
        print_indent()
        target.println("end")
    end
    function visit_array(nodes)
        var idx = 0
        # Visit term "{"
        ++idx; target.print("{")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "expr")
            # Recursive Visit expr
            this.visit_expr(nodes[idx++].nodes)
        end
        # Visit term "}"
        ++idx; target.print("}")
    end
    function visit_switch_default(nodes)
        var idx = 0
        # Visit term "default"
        print_indent()
        ++idx; target.print("default")
        # Visit endl token
        ++idx; target.println("")
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
        # Visit term "end"
        print_indent()
        target.println("end")
    end
    function visit_using_list(nodes)
        var idx = 0
        # Recursive Visit module-list
        this.visit_module_list(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
            # Visit term ","
            ++idx; target.print(", ")
            # Recursive Visit using-list
            this.visit_using_list(nodes[idx++].nodes)
        end
    end
    function visit_cond_expr(nodes)
        var idx = 0
        # Recursive Visit logic-or-expr
        this.visit_logic_or_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "cond-postfix")
            # Recursive Visit cond-postfix
            this.visit_cond_postfix(nodes[idx++].nodes)
        end
    end
    function visit_cond_postfix(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "?")
                matched = true
                # Visit term "?"
                ++idx; target.print(" ? ")
                # Recursive Visit logic-or-expr
                this.visit_logic_or_expr(nodes[idx++].nodes)
                # Visit term ":"
                ++idx; target.print(" : ")
                # Recursive Visit cond-expr
                this.visit_cond_expr(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ":")
                matched = true
                # Visit term ":"
                ++idx; target.print(" : ")
                # Recursive Visit logic-or-expr
                this.visit_logic_or_expr(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_decl_stmts(nodes)
        var idx = 0
        ++indent
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "declaration")
            # Recursive Visit declaration
            this.visit_declaration(nodes[idx++].nodes)
            # Repeat
            while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "endl")
                # Visit endl token
                ++idx
            end
        end
        --indent
    end
    function visit_import_list(nodes)
        var idx = 0, wildcard = false
        target.print("import ")
        # Recursive Visit module-list
        this.visit_module_list(nodes[idx++].nodes)
        if !stack.empty() && stack.front == "import_wildcard"
            wildcard = true
            idx = 0
            target.print("; using ")
            # Recursive Visit module-list
            this.visit_module_list(nodes[idx++].nodes)
        end
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "as")
            if wildcard
                error(nodes[idx].pos, "Can not bind name alias to wildcard symbol.")
            end
            # Visit term "as"
            ++idx; target.print(" as ")
            # Visit id token
            target.print(nodes[idx++].data)
        end
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
            # Visit term ","
            ++idx; target.println("")
            # Recursive Visit import-list
            this.visit_import_list(nodes[idx++].nodes)
        end
    end
    function visit_throw_stmt(nodes)
        var idx = 0
        # Visit term "throw"
        ++idx; target.print("throw ")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "expr")
            target.print("ecs.throw_exception(")
            # Recursive Visit expr
            this.visit_expr(nodes[idx++].nodes)
            target.print(")")
        else
            target.print("runtime.exception(\"__ecs_except__\")")
        end
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_endline(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "endl")
                matched = true
                # Visit endl token
                ++idx; target.println("")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ";")
                matched = true
                # Visit term ";"
                if minmal
                    ++idx; target.print(";")
                else
                    ++idx; target.println("")
                end
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_try_stmt(nodes)
        var idx = 0
        # Visit term "try"
        ++idx; target.print("try ")
        # Visit endl token
        ++idx; target.println("")
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
        stack.push_front("try")
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "catch-stmt")
            stack.push_front(new catch_type)
            # Recursive Visit catch-stmt
            this.visit_catch_stmt(nodes[idx++].nodes)
            # Recursive Visit stmts
            stack.front.body = nodes[idx++].nodes
            # this.visit_stmts(nodes[idx++].nodes)
        end
        print_indent()
        target.println("catch __ecs_except__")
        ++indent
        var default_catch = null
        print_indent()
        target.println("var __ecs_catch__ = false")
        print_indent()
        target.println("if __ecs_except__.what == \"__ecs_except__\"")
        ++indent
        while typeid stack.front != typeid string || stack.front != "try"
            var dat = stack.pop_front()
            if dat.type == null
                if default_catch != null
                    error(dat.pos, "Reduplicated generic catch statement.")
                end
                default_catch = dat
                continue
            else
                print_indent()
                target.print("if !__ecs_catch__ && typeid ecs.current_except == typeid ")
                this.visit_visit_expr(dat.type)
                target.println("")
            end
            ++indent
            print_indent()
            target.println("__ecs_catch__ = true")
            print_indent()
            target.println("var " + default_catch.id + " = ecs.get_exception()")
            --indent
            this.visit_stmts(dat.body)
            print_indent()
            target.println("end")
        end
        --indent
        print_indent()
        target.println("end")
        if default_catch != null
            print_indent()
            target.println("if !__ecs_catch__")
            ++indent
            print_indent()
            target.println("link " + default_catch.id + " = __ecs_except__")
            --indent
            this.visit_stmts(default_catch.body)
        end
        print_indent()
        target.println("end")
        --indent
        # Visit term "end"
        print_indent()
        target.println("end")
    end
    function visit_function_stmt(nodes)
        var idx = 0
        stack.push_front("function")
        # Visit term "function"
        ++idx; target.print("function ")
        # Visit id token
        target.print(nodes[idx++].data)
        # Visit term "("
        ++idx; target.print("(")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "argument-list")
            # Recursive Visit argument-list
            this.visit_argument_list(nodes[idx++].nodes, true)
        end
        # Visit term ")"
        ++idx; target.print(")")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "override")
            # Visit term "override"
            ++idx; target.print(" override")
        end
        target.println("")
        ++indent
        while typeid stack.front != typeid string || stack.front != "function"
            link map = stack.front.second
            if map.exist("pass-by-value")
                print_indent()
                target.println(stack.front.first + " := clone(" + stack.front.first + ")")
            end
            if map.exist("check-type")
                print_indent()
                target.print("ecs.check_type(\"" + stack.front.first + "\", " + stack.front.first + ", ")
                this.visit_visit_expr(map["check-type"])
                target.println(")")
            end
            stack.pop_front()
        end
        stack.pop_front()
        --indent
        # Recursive Visit function-body
        this.visit_function_body(nodes[idx++].nodes)
    end
    function visit_function_body(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "{")
                matched = true
                # Visit term "{"
                ++idx
                # Recursive Visit stmts
                this.visit_stmts(nodes[idx++].nodes)
                # Visit term "}"
                ++idx; target.println("end")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "endl")
                matched = true
                # Visit endl token
                ++idx
                # Recursive Visit stmts
                this.visit_stmts(nodes[idx++].nodes)
                # Visit term "end"
                print_indent()
                target.println("end")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_loop_stmt(nodes)
        var idx = 0
        # Visit term "loop"
        ++idx; target.print("loop")
        # Visit endl token
        ++idx; target.println("")
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
        print_indent()
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "until-stmt")
                matched = true
                # Recursive Visit until-stmt
                this.visit_until_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "end")
                matched = true
                # Visit term "end"
                target.println("end")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_control_stmt(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "break")
                matched = true
                # Visit term "break"
                ++idx; target.print("break")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "continue")
                matched = true
                # Visit term "continue"
                ++idx; target.print("continue")
            end
            if !matched
            	# Error
            	return
            end
        end
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_logic_or_expr(nodes)
        var idx = 0
        # Recursive Visit logic-and-expr
        this.visit_logic_and_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "||" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "or")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "||")
                    matched = true
                    # Visit term "||"
                    ++idx; target.print(" || ")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "or")
                    matched = true
                    # Visit term "or"
                    ++idx; target.print(" or ")
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit logic-or-expr
            this.visit_logic_or_expr(nodes[idx++].nodes)
        end
    end
    function visit_package_stmt(nodes)
        var idx = 0
        if is_package
            error(nodes[1].pos, "Multiple definition of package name.")
        end
        is_package = true
        # Visit term "package"
        ++idx; target.print("package ")
        # Visit id token
        target.print(nodes[idx++].data)
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_until_stmt(nodes)
        var idx = 0
        # Visit term "until"
        ++idx; target.print("until ")
        # Recursive Visit basic-expr
        this.visit_basic_expr(nodes[idx++].nodes)
        # Visit endl token
        target.println("")
    end
    function visit_equal_expr(nodes)
        var idx = 0
        # Recursive Visit relat-expr
        this.visit_relat_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "==" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "!=")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "==")
                    matched = true
                    # Visit term "=="
                    ++idx; target.print(" == ")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "!=")
                    matched = true
                    # Visit term "!="
                    ++idx; target.print(" != ")
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit equal-expr
            this.visit_equal_expr(nodes[idx++].nodes)
        end
    end
    function visit_unary_op(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "typeid")
                matched = true
                # Visit term "typeid"
                ++idx; target.print("typeid ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "++")
                matched = true
                # Visit term "++"
                ++idx; target.print("++")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "--")
                matched = true
                # Visit term "--"
                ++idx; target.print("--")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "*")
                matched = true
                # Visit term "*"
                ++idx; target.print("*")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "&")
                matched = true
                # Visit term "&"
                ++idx; target.print("&")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "-")
                matched = true
                # Visit term "-"
                ++idx; target.print("-")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "!")
                matched = true
                # Visit term "!"
                ++idx; target.print("!")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_var_def(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "var-bind")
                matched = true
                # Recursive Visit var-bind
                this.visit_var_bind(nodes[idx++].nodes)
                # Visit term "="
                ++idx; target.print(" = ")
                # Recursive Visit basic-expr
                this.visit_basic_expr(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "var-list")
                matched = true
                # Recursive Visit var-list
                this.visit_var_list(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_expr_stmt(nodes)
        var idx = 0
        # Recursive Visit expr
        this.visit_expr(nodes[idx++].nodes)
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_fcall(nodes)
        var idx = 0
        # Visit term "("
        ++idx; target.print("(")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "expr")
            # Recursive Visit expr
            this.visit_expr(nodes[idx++].nodes)
        end
        # Visit term ")"
        ++idx; target.print(")")
    end
    function visit_logic_and_expr(nodes)
        var idx = 0
        # Recursive Visit equal-expr
        this.visit_equal_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "&&" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "and")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "&&")
                    matched = true
                    # Visit term "&&"
                    ++idx; target.print(" && ")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "and")
                    matched = true
                    # Visit term "and"
                    ++idx; target.print(" and ")
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit logic-and-expr
            this.visit_logic_and_expr(nodes[idx++].nodes)
        end
    end
    function run(name, ast)
        var buff = new iostream.char_buff
        this.target = buff.get_ostream()
        this.target.println("import ecs")
        this.visit_begin(ast.nodes)
        var file_name = name + (is_package ? ".csp" : ".csc")
        this.target = iostream.ofstream(file_name)
        if !is_package
            target.println("#!/usr/bin/env cs")
        end
        if !minmal
            target.println("# Generated by Extended CovScript Compiler")
            target.println("# DO NOT MODIFY")
            target.print("# Date: " + to_string(runtime.local_time()))
        end
        for i = 0, i < lambda_list.size, ++i
            target.println("struct __ecs_lambda_impl_" + to_string(i + 1) + "__")
            indent = 1
            link dat = lambda_list[i]
            foreach it in dat.capture_list
                print_indent()
                target.println("var " + it.first + " = null")
            end
            print_indent()
            target.print("function construct(")
            if !dat.capture_list.empty()
                var str = new string
                foreach it in dat.capture_list
                    str += "_" + it.first + ", "
                end
                str.cut(2)
                target.print(str)
            end
            target.println(")")
            ++indent
            foreach it in dat.capture_list
                print_indent()
                if it.second
                    target.println("this." + it.first + " = _" + it.first)
                else
                    target.println("this." + it.first + " := _" + it.first)
                end
            end
            --indent
            print_indent()
            target.println("end")
            print_indent()
            target.print("function call(")
            if !dat.argument_list.empty()
                var str = new string
                foreach it in dat.argument_list
                    if it.second.exist("vargs")
                        str += "..." + it.first + ", "
                    else
                        str += it.first + ", "
                    end
                end
                str.cut(2)
                target.print(str)
            end
            target.println(")")
            ++indent
            print_indent()
            target.println("link self = this.call")
            foreach it in dat.argument_list
                link map = it.second
                if map.exist("pass-by-value")
                    print_indent()
                    target.println(it.first + " := clone(" + it.first + ")")
                end
                if map.exist("check-type")
                    print_indent()
                    target.print("ecs.check_type(\"" + it.first + "\", " + it.first + ", ")
                    this.visit_visit_expr(map["check-type"])
                    target.println(")")
                end
            end
            if dat.body_stmts != null
                foreach it in dat.body_stmts
                    this.visit_statement(it)
                end
            end
            if dat.body_expr != null
                print_indent()
                target.print("return ")
                this.visit_cond_expr(dat.body_expr)
                target.println("")
            end
            --indent
            print_indent()
            target.println("end")
            target.println("end")
        end
        target.println(buff)
        return file_name
    end
end

import ecs_parser, regex

function show_version()
@begin
    system.out.println(
        "Version: " + ecs_info.version + "\n" +
        "Copyright (C) 2017-2021 Michael Lee. All rights reserved.\n" +
        "Please visit http://covscript.org.cn/ for more information.\n\n" +
        "Metadata:\n" +
        "  STD Version: " + ecs_info.std_version + "\n"
    )
@end
    system.exit(0)
end

function show_help()
@begin
    system.out.println(
        "Usage: ecs [options...] <FILE> [arguments...]\n\n" +
        "Options:\n" +
        "    Option   Function\n" +
        "   -h        Show help information\n" +
        "   -v        Show version infomation\n" +
        "   -o        Save compile result\n" +
        "   -m        Disable beautify\n" +
        "   -c        Check grammar only\n" +
        "   --<ARGS>  Pass parameters to CovScript\n"
    )
@end
    system.exit(0)
end

var compiler_args = new string
var file_name = new string
var arguments = new string
var output = false
var minmal = false
var no_run = false

function process_args(cmd_args)
    var index = 1
    while index < cmd_args.size && cmd_args[index][0] == '-'
        switch cmd_args[index]
            default
                var reg = regex.build("^--(.+)$")
                var result = reg.match(cmd_args[index])
                if !result.empty()
                    compiler_args = result.str(1)
                else
                    system.out.println("Error: Unknown Option \"" + cmd_args[index] + "\"")
                    system.exit(0)
                end
            end
            case "-v"
                show_version()
            end
            case "-h"
                show_help()
            end
            case "-o"
                output = true
            end
            case "-m"
                minmal = true
            end
            case "-c"
                no_run = true
            end
        end
        ++index
    end
    if index == cmd_args.size
        system.out.println("Error: no input file.")
        system.exit(0)
    end
    file_name = cmd_args[index++]
    while index < cmd_args.size
        arguments += " " + cmd_args[index++] 
    end
end

var ecs_reg = regex.build("^(.*)\\.ecs$")
var lcs_reg = regex.build("^(.*)\\.(csc|csp)$")

function match(reg, str)
    return !reg.match(str).empty()
end

function main(cmd_args)
    process_args(cmd_args)
    if !match(regex.build(ecs_parser.grammar.ext), file_name)
        system.out.println("Error: invalid input file.")
        system.exit(0)
    end
    if !output
        minmal = true
    end
    var parser = new parsergen.generator
    parser.add_grammar("ecs-lang", ecs_parser.grammar)
    parser.from_file(file_name)
    if !no_run && parser.ast != null
        if match(lcs_reg, file_name)
            system.exit(system.run("cs " + compiler_args + " " + file_name + arguments))
        end
        var codegen = new generator
        codegen.code_buff = parser.code_buff
        codegen.file_name = file_name
        codegen.minmal = minmal
        if output
            var result = ecs_reg.match(file_name)
            if !result.empty()
                var name = codegen.run(result.str(1), parser.ast)
                system.exit(system.run("cs " + compiler_args + " " + name + arguments))
            end
        else
            system.path.mkdir_p("./.ecs_output/")
            var name = codegen.run("./.ecs_output/" + to_string(runtime.hash(file_name)), parser.ast)
            system.exit(system.run("cs " + compiler_args + " " + name + arguments))
        end
    end
end