# Extended Covariant Script Generator
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Copyright (C) 2017-2023 Michael Lee(李登淳)
#
# Email:   lee@unicov.cn, mikecovlee@163.com
# Github:  https://github.com/mikecovlee
# Website: http://covscript.org.cn
#
# Generated by CovScript AST Visitor Generator

@require: 210504

package ecs_generator

# Version Schema:
#   1 . 0 . 0 [Version Code](Preview/Unstable/Stable) Build YYMMXX
#   |   |   |                           |                  |
#   |   | Minor                       State        Fixed Width Version
#   | Major
# Master
#
# Short Version Schema:
#   1 . 0 . 0 a/b/r - YYMMXX
#   |   |   |   |       |
#   |   |   | State    FWV
#   |   | Minor
#   | Major
# Master

namespace ecs_info
    constant version = "4.0.0 Cuon alpinus(Preview) Build 230405"
    constant std_version = "210605"
end

import parsergen, ecs

struct module_type
    var list = new array
end

struct lambda_type
    var capture_list = new array
    var argument_list = null
    var body_stmts = null
    var body_expr = null
    var pos = {0, 0}
end

struct catch_type
    var id = null
    var pos = {0, 0}
    var type = null
    var body = null
end

class generator
    var custom_header = new array
    var lambda_list = new array
    var file_name = new string
    var code_buff = new array
    var ecsx_hook = new hash_map
    var ecsx_path = new array
    var target = system.out
    var is_package = false
    var ecs_discard = 0
    var ecs_prefix = ""
    var stack = new array
    var slice_ext = false
    var minmal = false
    var indent = -1
    # Debug Info
    var gen_dbg_info = false
    var dbg_line_map = new array
    function println(str, pos)
        target.println(str)
        if gen_dbg_info
            if pos == null
                dbg_line_map.push_back("-")
            else
                dbg_line_map.push_back(to_string(pos[1]))
            end
        end
    end
    function error(pos, text)
        var err = new parsergen.lex_error
        err.text = text
        err.pos = pos
        parsergen.print_error(file_name, code_buff, {err})
        throw runtime.exception("ECS_ERROR")
    end
    function warning(pos, text)
        var err = new parsergen.lex_error
        err.text = "warning: " + text
        err.pos = pos
        parsergen.print_error(file_name, code_buff, {err})
    end
    function print_indent()
        if !minmal
            foreach i in range(indent) do target.print('\t')
        end
    end
    function get_id_of_visit_expr(nodes)
        if nodes.size == 1 && typeid nodes[0] == typeid parsergen.syntax_tree && nodes[0].root == "object"
            nodes := nodes[0].nodes
            if nodes.size == 1 && typeid nodes[0] == typeid parsergen.syntax_tree && nodes[0].root == "element"
                nodes := nodes[0].nodes
                if nodes.size == 1 && typeid nodes[0] == typeid parsergen.token_type && nodes[0].type == "id"
                    return nodes[0].data
                end
            end
        end
        return null
    end
    function get_id_of_equal_expr(nodes)
        if nodes.size == 1 && typeid nodes[0] == typeid parsergen.syntax_tree && nodes[0].root == "relat-expr"
            nodes := nodes[0].nodes
            if nodes.size == 1 && typeid nodes[0] == typeid parsergen.syntax_tree && nodes[0].root == "add-expr"
                nodes := nodes[0].nodes
                if nodes.size == 1 && typeid nodes[0] == typeid parsergen.syntax_tree && nodes[0].root == "mul-expr"
                    nodes := nodes[0].nodes
                    if nodes.size == 1 && typeid nodes[0] == typeid parsergen.syntax_tree && nodes[0].root == "conv-expr"
                        nodes := nodes[0].nodes
                        if nodes.size == 1 && typeid nodes[0] == typeid parsergen.syntax_tree && nodes[0].root == "unary-expr"
                            nodes := nodes[0].nodes
                            if nodes.size == 1 && typeid nodes[0] == typeid parsergen.syntax_tree && nodes[0].root == "prim-expr"
                                nodes := nodes[0].nodes
                                if nodes.size == 1 && typeid nodes[0] == typeid parsergen.syntax_tree && nodes[0].root == "visit-expr"
                                    return get_id_of_visit_expr(nodes[0].nodes)
                                end
                            end
                        end
                    end
                end
            end
        end
        return null
    end
    function gen_unique_discard_id()
        return "__ecs_discard_" + ecs_prefix + to_string(++ecs_discard) + "__"
    end
    function register_ecsx(path, hook)
        var ecsx = context.source_import(path)
        ecsx.ecsx_main(hook)
    end
    function find_ecsx(name)
        var ecsx_search = ecsx_path
        var csp_import = runtime.get_import_path()
        foreach it in csp_import.split({system.path.delimiter}) do ecsx_search.push_back(it)
        foreach path in ecsx_search
            var full = path + system.path.separator + name + ".ecsx"
            if system.file.exist(full)
                var hooks = new hash_map
                register_ecsx(full, hooks)
                return {name, hooks}
            end
        end
    end
    function visit_declaration(nodes)
        print_indent()
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "prep-stmt")
                matched = true
                # Recursive Visit prep-stmt
                this.visit_prep_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "namespace-stmt")
                matched = true
                # Recursive Visit namespace-stmt
                this.visit_namespace_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "var-stmt")
                matched = true
                # Recursive Visit var-stmt
                this.visit_var_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "using-stmt")
                matched = true
                # Recursive Visit using-stmt
                this.visit_using_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "function-stmt")
                matched = true
                # Recursive Visit function-stmt
                this.visit_function_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "class-stmt")
                matched = true
                # Recursive Visit class-stmt
                this.visit_class_stmt(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_module_list(nodes)
        var idx = 0
        # Visit id token
        if stack.front.list.empty()
            target.print(nodes[idx].data)
        end
        stack.front.list.push_back(nodes[idx++])
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ".")
            # Visit term "."
            ++idx
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "*")
                    matched = true
                    # Visit term "*"
                    stack.front.list.push_back(nodes[idx++])
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "module-list")
                    matched = true
                    # Recursive Visit module-list
                    this.visit_module_list(nodes[idx++].nodes)
                end
                if !matched
                	# Error
                	return
                end
            end
        end
    end
    function visit_expr(nodes)
        var idx = 0
        # Recursive Visit basic-expr
        this.visit_basic_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
            # Visit term ","
            ++idx; target.print(", ")
            # Recursive Visit expr
            this.visit_expr(nodes[idx++].nodes)
        end
    end
    function visit_block_stmt(nodes)
        var idx = 0
        # Visit term "block"
        ++idx; target.print("block ")
        # Visit endl token
        ++idx; println("", nodes.front.pos)
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
        # Visit term "end"
        print_indent()
        println("end", {0, nodes.back.pos[1] - 1})
    end
    function visit_endblock(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "end-stmt")
                matched = true
                # Recursive Visit end-stmt
                this.visit_end_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "else-stmt")
                matched = true
                # Recursive Visit else-stmt
                this.visit_else_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "until-stmt")
                matched = true
                # Recursive Visit until-stmt
                this.visit_until_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "catch-stmt")
                matched = true
                # Recursive Visit catch-stmt
                this.visit_catch_stmt(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_stmts(nodes)
        var idx = 0
        ++indent
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "statement")
            # Recursive Visit statement
            this.visit_statement(nodes[idx++].nodes)
            # Repeat
            while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "endl")
                # Visit endl token
                ++idx
            end
        end
        --indent
    end
    function visit_begin(nodes)
        var idx = 0
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
    end
    function visit_statement(nodes)
        print_indent()
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "prep-stmt")
                matched = true
                # Recursive Visit prep-stmt
                this.visit_prep_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "package-stmt")
                matched = true
                # Recursive Visit package-stmt
                this.visit_package_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "import-stmt")
                matched = true
                # Recursive Visit import-stmt
                this.visit_import_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "var-stmt")
                matched = true
                # Recursive Visit var-stmt
                this.visit_var_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "block-stmt")
                matched = true
                # Recursive Visit block-stmt
                this.visit_block_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "namespace-stmt")
                matched = true
                # Recursive Visit namespace-stmt
                this.visit_namespace_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "using-stmt")
                matched = true
                # Recursive Visit using-stmt
                this.visit_using_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "if-stmt")
                matched = true
                # Recursive Visit if-stmt
                this.visit_if_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "switch-stmt")
                matched = true
                # Recursive Visit switch-stmt
                this.visit_switch_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "while-stmt")
                matched = true
                # Recursive Visit while-stmt
                this.visit_while_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "loop-stmt")
                matched = true
                # Recursive Visit loop-stmt
                this.visit_loop_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "for-stmt")
                matched = true
                # Recursive Visit for-stmt
                this.visit_for_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "foreach-stmt")
                matched = true
                # Recursive Visit foreach-stmt
                this.visit_foreach_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "control-stmt")
                matched = true
                # Recursive Visit control-stmt
                this.visit_control_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "function-stmt")
                matched = true
                # Recursive Visit function-stmt
                this.visit_function_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "return-stmt")
                matched = true
                # Recursive Visit return-stmt
                this.visit_return_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "try-stmt")
                matched = true
                # Recursive Visit try-stmt
                this.visit_try_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "throw-stmt")
                matched = true
                # Recursive Visit throw-stmt
                this.visit_throw_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "class-stmt")
                matched = true
                # Recursive Visit class-stmt
                this.visit_class_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "expr-stmt")
                matched = true
                # Recursive Visit expr-stmt
                this.visit_expr_stmt(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_var_bind_list(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "id")
                matched = true
                # Visit id token
                target.print(nodes[idx++].data)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "...")
                matched = true
                # Visit ... token
                target.print(gen_unique_discard_id())
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "var-bind")
                matched = true
                # Recursive Visit var-bind
                this.visit_var_bind(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_for_stmt(nodes)
        var idx = 0
        # Visit term "for"
        ++idx; target.print("for ")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "var-def")
            # Recursive Visit var-def
            this.visit_var_def(nodes[idx++].nodes)
        end
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ";")
                matched = true
                # Visit term ";"
                ++idx; target.print(", ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
                matched = true
                # Visit term ","
                ++idx; target.print(", ")
            end
            if !matched
            	# Error
            	return
            end
        end
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "basic-expr")
            # Recursive Visit basic-expr
            this.visit_basic_expr(nodes[idx++].nodes)
        end
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ";")
                matched = true
                # Visit term ";"
                ++idx; target.print(", ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
                matched = true
                # Visit term ","
                ++idx; target.print(", ")
            end
            if !matched
            	# Error
            	return
            end
        end
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "basic-expr")
            # Recursive Visit basic-expr
            this.visit_basic_expr(nodes[idx++].nodes)
        end
        # Recursive Visit for-body
        this.visit_for_body(nodes[idx++].nodes, nodes.front.pos)
    end
    function visit_for_body(nodes, header_pos)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "do")
                matched = true
                # Visit term "do"
                ++idx; target.print(" do ")
                # Recursive Visit basic-expr
                this.visit_basic_expr(nodes[idx++].nodes)
                # Recursive Visit endline
                this.visit_endline(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "endl")
                matched = true
                # Visit endl token
                ++idx; println("", header_pos)
                # Recursive Visit stmts
                this.visit_stmts(nodes[idx++].nodes)
                # Visit term "end"
                print_indent()
                println("end", {0, nodes.back.pos[1] - 1})
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_class_stmt(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "class")
                matched = true
                # Visit term "class"
                ++idx; target.print("class ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "struct")
                matched = true
                # Visit term "struct"
                ++idx; target.print("struct ")
            end
            if !matched
            	# Error
            	return
            end
        end
        # Visit id token
        target.print(nodes[idx++].data)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "extends")
            # Visit term "extends"
            ++idx; target.print(" extends ")
            # Recursive Visit visit-expr
            this.visit_visit_expr(nodes[idx++].nodes)
        end
        # Visit endl token
        ++idx; println("", nodes.front.pos)
        # Recursive Visit decl-stmts
        this.visit_decl_stmts(nodes[idx++].nodes)
        # Visit term "end"
        print_indent()
        println("end", {0, nodes.back.pos[1] - 1})
    end
    function visit_capture_list(nodes)
        var idx = 0
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "=")
            # Visit term "="
            ++idx
            stack.front.capture_list.push_back(nodes[idx].data : true)
        else
            stack.front.capture_list.push_back(nodes[idx].data : false)
        end
        # Visit id token
        ++idx
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
            # Visit term ","
            ++idx
            # Recursive Visit capture-list
            this.visit_capture_list(nodes[idx++].nodes)
        end
    end
    function visit_catch_stmt(nodes)
        var idx = 0
        # Visit term "catch"
        stack.front.pos = nodes.front.pos
        ++idx
        # Visit id token
        stack.front.id = nodes[idx++].data
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ":")
            # Visit term ":"
            ++idx
            # Recursive Visit visit-expr
            stack.front.type = nodes[idx++].nodes
            # this.visit_visit_expr(nodes[idx++].nodes)
        end
    end
    function visit_else_stmt(nodes)
        var idx = 0
        # Visit term "else"
        print_indent()
        ++idx; println("else", nodes.front.pos)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "if")
            stack.push_front("elif")
            ++indent
            print_indent()
            # Visit term "if"
            ++idx; target.print("if ")
            # Recursive Visit basic-expr
            this.visit_basic_expr(nodes[idx++].nodes)
            # Visit endl token
            println("", {0, nodes.back.pos[1] - 1})
        end
    end
    function visit_unary_expr(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "unary-op")
                matched = true
                # Recursive Visit unary-op
                this.visit_unary_op(nodes[idx++].nodes)
                # Recursive Visit unary-expr
                this.visit_unary_expr(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "new" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "gcnew")
                matched = true
                # Optional
                if nodes.size > 2 && (typeid nodes[2] == typeid parsergen.syntax_tree && nodes[2].root == "array")
                    var id = get_id_of_visit_expr(nodes[1].nodes)
                    if id != null && ecs.internal_type.exist(id)
                        # Condition
                        block
                            var matched = false
                            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "new")
                                matched = true
                                # Visit term "new"
                                ++idx; target.print(ecs_prefix + "ecs.type_constructor.__" + id + "(")
                            end
                            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "gcnew")
                                matched = true
                                # Visit term "gcnew"
                                ++idx; target.print(ecs_prefix + "&ecs.type_constructor.__" + id + "(")
                            end
                            if !matched
                                # Error
                                return
                            end
                        end
                        # Recursive Visit visit-expr
                        idx++
                        # Recursive Visit array
                        this.visit_array(nodes[idx++].nodes)
                        target.print("...)")
                    else
                        # Condition
                        block
                            var matched = false
                            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "new")
                                matched = true
                                # Visit term "new"
                                ++idx; target.print(ecs_prefix + "ecs.param_new(")
                            end
                            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "gcnew")
                                matched = true
                                # Visit term "gcnew"
                                ++idx; target.print(ecs_prefix + "ecs.param_gcnew(")
                            end
                            if !matched
                                # Error
                                return
                            end
                        end
                        # Recursive Visit visit-expr
                        this.visit_visit_expr(nodes[idx++].nodes)
                        target.print(", ")
                        # Recursive Visit array
                        this.visit_array(nodes[idx++].nodes)
                        target.print(")")
                    end
                else
                    # Condition
                    block
                        var matched = false
                        if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "new")
                            matched = true
                            # Visit term "new"
                            ++idx; target.print("new ")
                        end
                        if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "gcnew")
                            matched = true
                            # Visit term "gcnew"
                            ++idx; target.print("gcnew ")
                        end
                        if !matched
                            # Error
                            return
                        end
                    end
                    # Recursive Visit visit-expr
                    this.visit_visit_expr(nodes[idx++].nodes)
                end
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "prim-expr")
                matched = true
                # Recursive Visit prim-expr
                this.visit_prim_expr(nodes[idx++].nodes)
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "postfix-expr")
                    # Recursive Visit postfix-expr
                    this.visit_postfix_expr(nodes[idx++].nodes)
                end
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_constant(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "num")
                matched = true
                # Visit num token
                target.print(nodes[idx++].data)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "null")
                matched = true
                # Visit term "null"
                ++idx; target.print("null")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "true")
                matched = true
                # Visit term "true"
                ++idx; target.print("true")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "false")
                matched = true
                # Visit term "false"
                ++idx; target.print("false")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_var_bind(nodes)
        var idx = 0
        # Visit term "("
        ++idx; target.print("(")
        # Recursive Visit var-bind-list
        this.visit_var_bind_list(nodes[idx++].nodes)
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
            # Visit term ","
            ++idx; target.print(", ")
            # Recursive Visit var-bind-list
            this.visit_var_bind_list(nodes[idx++].nodes)
        end
        # Visit term ")"
        ++idx; target.print(")")
    end
    function visit_postfix_expr(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "++")
                matched = true
                # Visit term "++"
                ++idx; target.print("++")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "--")
                matched = true
                # Visit term "--"
                ++idx; target.print("--")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "...")
                matched = true
                # Visit term "..."
                ++idx; target.print("...")
            end
            if !matched
            	# Error
            	return
            end
        end
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "postfix-expr")
            # Recursive Visit postfix-expr
            this.visit_postfix_expr(nodes[idx++].nodes)
        end
    end
    function visit_lambda_expr(nodes)
        var idx = 0
        stack.push_front(new lambda_type)
        stack.front.pos = nodes.front.pos
        # Visit term "["
        ++idx
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "capture-list")
            # Recursive Visit capture-list
            this.visit_capture_list(nodes[idx++].nodes)
        end
        # Visit term "]"
        ++idx
        stack.push_front("function")
        # Visit term "("
        ++idx
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "argument-list")
            # Recursive Visit argument-list
            this.visit_argument_list(nodes[idx++].nodes, false)
        end
        # Visit term ")"
        ++idx
        var arg_list = new array
        while typeid stack.front != typeid string || stack.front != "function"
            arg_list.push_front(stack.front.first : stack.front.second)
            stack.pop_front()
        end
        stack.pop_front()
        stack.front.argument_list := arg_list
        # Recursive Visit lambda-body
        this.visit_lambda_body(nodes[idx++].nodes)
        link current_lambda = stack.front
        stack.pop_front()
        # Optimize for simple lambda
        if current_lambda.capture_list.empty()
            var simple_args = true
            foreach it in current_lambda.argument_list
                link map = it.second
                if map.exist("pass-by-value") || map.exist("check-type")
                    simple_args = false
                    break
                end
            end
            if simple_args && current_lambda.body_expr != null
                target.print("([](")
                if !current_lambda.argument_list.empty()
                    var str = new string
                    foreach it in current_lambda.argument_list
                        if it.second.exist("vargs")
                            str += "..." + it.first + ", "
                        else
                            str += it.first + ", "
                        end
                    end
                    str.cut(2)
                    target.print(str)
                end
                target.print(")->")
                this.visit_cond_expr(current_lambda.body_expr)
                target.print(")")
                return
            end
        end
        lambda_list.push_back(current_lambda)
        target.print(ecs_prefix + "ecs.init_lambda(global.__" + ecs_prefix + "ecs_lambda_impl_" + lambda_list.size + "__")
        var capture_str = ", "
        foreach it in current_lambda.capture_list
            capture_str += it.first + ", "
        end
        capture_str.cut(2)
        target.print(capture_str + ")")
    end
    function visit_relat_expr(nodes)
        var idx = 0
        # Recursive Visit add-expr
        this.visit_add_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ">" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "<" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ">=" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "<=")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ">")
                    matched = true
                    # Visit term ">"
                    ++idx; target.print(" > ")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "<")
                    matched = true
                    # Visit term "<"
                    ++idx; target.print(" < ")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ">=")
                    matched = true
                    # Visit term ">="
                    ++idx; target.print(" >= ")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "<=")
                    matched = true
                    # Visit term "<="
                    ++idx; target.print(" <= ")
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit relat-expr
            this.visit_relat_expr(nodes[idx++].nodes)
        end
    end
    function visit_import_stmt(nodes)
        var idx = 0
        # Visit term "import"
        ++idx
        # Recursive Visit import-list
        this.visit_import_list(nodes[idx++].nodes)
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_asi_op(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "=")
                matched = true
                # Visit term "="
                ++idx; target.print(" = ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ":=")
                matched = true
                # Visit term ":="
                ++idx; target.print(" := ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "+=")
                matched = true
                # Visit term "+="
                ++idx; target.print(" += ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "-=")
                matched = true
                # Visit term "-="
                ++idx; target.print(" -= ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "*=")
                matched = true
                # Visit term "*="
                ++idx; target.print(" *= ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "/=")
                matched = true
                # Visit term "/="
                ++idx; target.print(" /= ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "%=")
                matched = true
                # Visit term "%="
                ++idx; target.print(" %= ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "^=")
                matched = true
                # Visit term "^="
                ++idx; target.print(" ^= ")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_lambda_body(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "{")
                matched = true
                # Visit term "{"
                ++idx
                # Repeat
                while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "statement")
                    if stack.front.body_stmts == null
                        stack.front.body_stmts = new array
                    end
                    # Recursive Visit statement
                    stack.front.body_stmts.push_back(nodes[idx++].nodes)
                    # this.visit_statement(nodes[idx++].nodes)
                    # Repeat
                    while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "endl")
                        # Visit endl token
                        ++idx
                    end
                end
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "->")
                matched = true
                # Visit term "->"
                ++idx
                # Recursive Visit cond-expr
                stack.front.body_expr = nodes[idx++].nodes
                # this.visit_cond_expr(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_prep_stmt(nodes)
        # Visit prep token
        link prep = nodes.front.data
        if prep != "@begin" && prep != "@end"
            var cmd = prep.split({':'})
            if cmd.size == 2
                if cmd[0] == "@require"
                    var require_ver = new string
                    foreach ch in cmd[1]
                        if !ch.isspace()
                            require_ver += ch
                        end
                    end
                    if require_ver <= ecs_info.std_version
                        println("@require: 210503", nodes.front.pos)
                        return
                    else
                        error(nodes.front.pos, "Newer Language Standard required: " + require_ver + ", now on " + ecs_info.std_version)
                    end
                end
            end
            println(prep, nodes.front.pos)
        end
    end
    function visit_argument_list(nodes, print)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "...")
                matched = true
                # Visit term "..."
                ++idx
                if print
                    target.print("...")
                else
                    stack.push_front(nodes[idx].data : {"vargs" : null}.to_hash_map())
                end
                # Visit id token
                if print
                    target.print(nodes[idx++].data)
                end
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "=" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "id")
                matched = true
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "=")
                    stack.push_front(nodes[++idx].data : {"pass-by-value" : null}.to_hash_map())
                    # Visit term "="
                    # target.print("=")
                else
                    stack.push_front(nodes[idx].data : new hash_map)
                end
                # Visit id token
                if print
                    target.print(nodes[idx++].data)
                else
                    ++idx
                end
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ":")
                    # Visit term ":"
                    ++idx
                    # Recursive Visit visit-expr
                    stack.front.second.insert("check-type", nodes[idx++].nodes)
                    # this.visit_visit_expr(nodes[idx++].nodes)
                end
                # Repeat
                while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
                    # Visit term ","
                    ++idx
                    if print
                        target.print(", ")
                    end
                    # Recursive Visit argument-list
                    this.visit_argument_list(nodes[idx++].nodes, print)
                end
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_visit_expr(nodes)
        var idx = 0
        # Recursive Visit object
        this.visit_object(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "->" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ".")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "->")
                    matched = true
                    # Visit term "->"
                    ++idx; target.print("->")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ".")
                    matched = true
                    # Visit term "."
                    ++idx; target.print(".")
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit visit-expr
            this.visit_visit_expr(nodes[idx++].nodes)
        end
    end
    function visit_basic_expr(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "var-bind")
                matched = true
                # Recursive Visit var-bind
                this.visit_var_bind(nodes[idx++].nodes)
                # Visit term "="
                ++idx; target.print(" = ")
                # Recursive Visit cond-expr
                this.visit_cond_expr(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "cond-expr")
                matched = true
                # Recursive Visit cond-expr
                this.visit_cond_expr(nodes[idx++].nodes)
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "asi-op")
                    # Recursive Visit asi-op
                    this.visit_asi_op(nodes[idx++].nodes)
                    # Recursive Visit basic-expr
                    this.visit_basic_expr(nodes[idx++].nodes)
                end
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_mul_expr(nodes)
        var idx = 0
        # Recursive Visit conv-expr
        this.visit_conv_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "*" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "/" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "%" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "^")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "*")
                    matched = true
                    # Visit term "*"
                    ++idx; target.print("*")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "/")
                    matched = true
                    # Visit term "/"
                    ++idx; target.print("/")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "%")
                    matched = true
                    # Visit term "%"
                    ++idx; target.print("%")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "^")
                    matched = true
                    # Visit term "^"
                    ++idx; target.print("^")
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit mul-expr
            this.visit_mul_expr(nodes[idx++].nodes)
        end
    end
    function visit_conv_expr(nodes)
        if nodes.size > 1
            # Recursive Visit visit-expr
            link visit_expr_nodes = nodes[2].nodes
            var id = get_id_of_visit_expr(visit_expr_nodes)
            if id != null && ecs.internal_type.exist(id)
                target.print(ecs_prefix + "ecs.type_constructor.__" + id + "(")
                # Recursive Visit unary-expr
                this.visit_unary_expr(nodes[0].nodes)
                target.print(")")
            else
                target.print(ecs_prefix + "ecs.param_new(")
                this.visit_visit_expr(visit_expr_nodes)
                target.print(", {")
                # Recursive Visit unary-expr
                this.visit_unary_expr(nodes[0].nodes)
                target.print("})")
            end
        else
            # Recursive Visit unary-expr
            this.visit_unary_expr(nodes[0].nodes)
        end
    end
    function visit_switch_stmts(nodes)
        var idx = 0
        ++indent
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "switch-case" || typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "switch-default")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "switch-case")
                    matched = true
                    # Recursive Visit switch-case
                    this.visit_switch_case(nodes[idx++].nodes)
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "switch-default")
                    matched = true
                    # Recursive Visit switch-default
                    this.visit_switch_default(nodes[idx++].nodes)
                end
                if !matched
                	# Error
                	return
                end
            end
            # Repeat
            while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "endl")
                # Visit endl token
                ++idx
            end
        end
        --indent
    end
    function visit_index(nodes)
        if nodes.size == 2
            error(nodes.front.pos, "Expect expression or slicing in index operator.")
        end
        if nodes.size > 3
            var idx = 1
            slice_ext = true
            target.print(".ecs_slice_ext(")
            if idx < nodes.size && typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "add-expr"
                this.visit_add_expr(nodes[idx].nodes)
                ++idx
            else
                target.print("null")
            end
            target.print(", ")
            ++idx
            if idx < nodes.size && typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "add-expr"
                this.visit_add_expr(nodes[idx].nodes)
                ++idx
            else
                target.print("null")
            end
            target.print(", ")
            ++idx
            if idx < nodes.size && typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "add-expr"
                this.visit_add_expr(nodes[idx].nodes)
                ++idx
            else
                target.print("null")
            end
            target.print(")")
        else
            if typeid nodes[1] == typeid parsergen.syntax_tree && nodes[1].root == "add-expr"
                target.print("[")
                this.visit_add_expr(nodes[1].nodes)
                target.print("]")
            end
        end
    end
    function visit_var_list(nodes)
        var idx = 0
        # Visit id token
        target.print(nodes[idx++].data)
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "=")
                matched = true
                # Visit term "="
                ++idx; target.print(" = ")
                # Recursive Visit basic-expr
                this.visit_basic_expr(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "as")
                matched = true
                # Visit term "as"
                ++idx; target.print(" = ")
                # Optional
                if nodes.size > 3 && (typeid nodes[3] == typeid parsergen.syntax_tree && nodes[3].root == "array")
                    target.print(ecs_prefix + "ecs.param_new(")
                    # Recursive Visit unary-expr
                    this.visit_unary_expr(nodes[idx++].nodes)
                    target.print(", ")
                    # Recursive Visit array
                    this.visit_array(nodes[idx++].nodes)
                    target.print(")")
                else
                    target.print("new ")
                    # Recursive Visit unary-expr
                    this.visit_unary_expr(nodes[idx++].nodes)
                end
            end
            if !matched
            	# Error
            	return
            end
        end
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
            # Visit term ","
            ++idx; target.print(", ")
            # Recursive Visit var-list
            this.visit_var_list(nodes[idx++].nodes)
        end
    end
    function visit_if_stmt(nodes)
        var idx = 0
        stack.push_front("if")
        # Visit term "if"
        ++idx; target.print("if ")
        # Recursive Visit basic-expr
        this.visit_basic_expr(nodes[idx++].nodes)
        # Visit endl token
        ++idx; println("", nodes.front.pos)
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "else-stmt")
            # Recursive Visit else-stmt
            this.visit_else_stmt(nodes[idx++].nodes)
            # Recursive Visit stmts
            this.visit_stmts(nodes[idx++].nodes)
        end
        while !stack.empty() && stack.front == "elif"
            stack.pop_front()
            print_indent()
            println("end", {0, nodes.back.pos[1] - 1})
            --indent
        end
        stack.pop_front()
        # Visit term "end"
        print_indent()
        println("end", {0, nodes.back.pos[1] - 1})
    end
    function visit_switch_case(nodes)
        var idx = 0
        # Visit term "case"
        print_indent()
        ++idx; target.print("case ")
        # Recursive Visit logic-or-expr
        this.visit_logic_or_expr(nodes[idx++].nodes)
        # Visit endl token
        ++idx; println("", nodes.front.pos)
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
        # Visit term "end"
        print_indent()
        println("end", {0, nodes.back.pos[1] - 1})
    end
    function visit_foreach_stmt(nodes)
        var idx = 0
        # Visit term "foreach"
        ++idx; target.print("foreach ")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "id")
            # Visit id token
            target.print(nodes[idx++].data + " ")
        end
        # Visit term "in"
        ++idx; target.print("in ")
        # Recursive Visit basic-expr
        this.visit_basic_expr(nodes[idx++].nodes)
        # Recursive Visit for-body
        this.visit_for_body(nodes[idx++].nodes, nodes.front.pos)
    end
    function visit_var_stmt(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "var")
                matched = true
                # Visit term "var"
                ++idx; target.print("var ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "link")
                matched = true
                # Visit term "link"
                ++idx; target.print("link ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "constant")
                matched = true
                # Visit term "constant"
                ++idx; target.print("constant ")
            end
            if !matched
            	# Error
            	return
            end
        end
        # Recursive Visit var-def
        this.visit_var_def(nodes[idx++].nodes)
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_ecsx_extend(nodes)
        var ecsx = nodes[0].data, func = nodes[2].data, ast = nodes.size > 5 ? nodes[4] : null
        if !ecsx_hook.exist(ecsx)
            error(nodes[0].pos, "ECSX extend module not found.")
        end
        if !ecsx_hook.at(ecsx).exist(func)
            error(nodes[2].pos, "Function not found in ECSX extend module.")
        end
        ecsx_hook.at(ecsx).at(func)(this, ast, nodes[2].pos)
    end
    function visit_object(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "array")
                matched = true
                # Recursive Visit array
                this.visit_array(nodes[idx++].nodes)
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "index")
                    # Recursive Visit index
                    this.visit_index(nodes[idx++].nodes)
                end
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "str")
                matched = true
                # Visit str token
                target.print(nodes[idx++].data)
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "index")
                    # Recursive Visit index
                    this.visit_index(nodes[idx++].nodes)
                end
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "local")
                matched = true
                # Visit term "local"
                ++idx; target.print("local")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "global")
                matched = true
                # Visit term "global"
                ++idx; target.print("global")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "ecsx-extend")
                matched = true
                # Recursive Visit ecsx-extend
                this.visit_ecsx_extend(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "element")
                matched = true
                # Recursive Visit element
                this.visit_element(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "char")
                matched = true
                # Visit char token
                target.print(nodes[idx++].data)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_using_stmt(nodes)
        var idx = 0
        # Visit term "using"
        ++idx; target.print("using ")
        # Recursive Visit using-list
        this.visit_using_list(nodes[idx++].nodes)
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_add_expr(nodes)
        var idx = 0
        # Recursive Visit mul-expr
        this.visit_mul_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "+" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "-")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "+")
                    matched = true
                    # Visit term "+"
                    ++idx; target.print(" + ")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "-")
                    matched = true
                    # Visit term "-"
                    ++idx; target.print(" - ")
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit add-expr
            this.visit_add_expr(nodes[idx++].nodes)
        end
    end
    function visit_prim_expr(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "visit-expr")
                matched = true
                # Recursive Visit visit-expr
                this.visit_visit_expr(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "constant")
                matched = true
                # Recursive Visit constant
                this.visit_constant(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_return_stmt(nodes)
        var idx = 0
        # Visit term "return"
        ++idx; target.print("return")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "expr")
            target.print(" ")
            # Recursive Visit expr
            this.visit_expr(nodes[idx++].nodes)
        end
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_while_stmt(nodes)
        var idx = 0
        # Visit term "while"
        ++idx; target.print("while ")
        # Recursive Visit basic-expr
        this.visit_basic_expr(nodes[idx++].nodes)
        # Visit endl token
        ++idx; println("", nodes.front.pos)
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
        # Visit term "end"
        print_indent()
        println("end", {0, nodes.back.pos[1] - 1})
    end
    function visit_switch_stmt(nodes)
        var idx = 0
        # Visit term "switch"
        ++idx; target.print("switch ")
        # Recursive Visit basic-expr
        this.visit_basic_expr(nodes[idx++].nodes)
        # Visit endl token
        ++idx; println("", nodes.front.pos)
        # Recursive Visit switch-stmts
        this.visit_switch_stmts(nodes[idx++].nodes)
        # Visit term "end"
        print_indent()
        println("end", {0, nodes.back.pos[1] - 1})
    end
    function visit_element(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "id")
                matched = true
                # Visit id token
                target.print(nodes[idx++].data)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "(")
                matched = true
                # Visit term "("
                ++idx; target.print("(")
                # Recursive Visit basic-expr
                this.visit_basic_expr(nodes[idx++].nodes)
                # Visit term ")"
                ++idx; target.print(")")
            end
            if !matched
            	# Error
            	return
            end
        end
        var expect_index = false
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "fcall" || typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "index")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "fcall")
                    matched = true
                    if expect_index
                        error(nodes[idx++].nodes.front.pos, "Serial function calls are not allowed.")
                    end
                    expect_index = true
                    # Recursive Visit fcall
                    this.visit_fcall(nodes[idx++].nodes)
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "index")
                    matched = true
                    expect_index = false
                    # Recursive Visit index
                    this.visit_index(nodes[idx++].nodes)
                end
                if !matched
                	# Error
                	return
                end
            end
        end
    end
    function visit_namespace_stmt(nodes)
        var idx = 0
        # Visit term "namespace"
        ++idx; target.print("namespace ")
        # Visit id token
        target.print(nodes[idx++].data)
        # Visit endl token
        ++idx; println("", nodes.front.pos)
        # Recursive Visit decl-stmts
        this.visit_decl_stmts(nodes[idx++].nodes)
        # Visit term "end"
        print_indent()
        println("end", {0, nodes.back.pos[1] - 1})
    end
    function visit_array(nodes)
        var idx = 0
        # Visit term "{"
        ++idx; target.print("{")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "expr")
            # Recursive Visit expr
            this.visit_expr(nodes[idx++].nodes)
        end
        # Visit term "}"
        ++idx; target.print("}")
    end
    function visit_switch_default(nodes)
        var idx = 0
        # Visit term "default"
        print_indent()
        ++idx; target.print("default")
        # Visit endl token
        ++idx; println("", nodes.front.pos)
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
        # Visit term "end"
        print_indent()
        println("end", {0, nodes.back.pos[1] - 1})
    end
    function visit_using_list(nodes)
        var idx = 0
        # Recursive Visit module-list
        stack.push_front(new module_type)
        this.visit_module_list(nodes[idx++].nodes)
        stack.front.list.pop_front()
        if !stack.front.list.empty() && stack.front.list.back.data == "*"
            error(stack.front.list.back.pos, "Can not use wildcard symbol in using statement.")
        end
        foreach it in stack.front.list
            target.print("." + it.data) 
        end
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
            # Visit term ","
            ++idx; target.print(", ")
            # Recursive Visit using-list
            this.visit_using_list(nodes[idx++].nodes)
        end
    end
    function visit_cond_expr(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "logic-or-expr")
                matched = true
                # Recursive Visit logic-or-expr
                this.visit_logic_or_expr(nodes[idx++].nodes)
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "cond-postfix")
                    # Recursive Visit cond-postfix
                    this.visit_cond_postfix(nodes[idx++].nodes)
                end
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "lambda-expr")
                matched = true
                # Recursive Visit lambda-expr
                this.visit_lambda_expr(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_value_expr(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "logic-or-expr")
                matched = true
                # Recursive Visit logic-or-expr
                this.visit_logic_or_expr(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "lambda-expr")
                matched = true
                # Recursive Visit lambda-expr
                this.visit_lambda_expr(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_cond_postfix(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "?")
                matched = true
                # Visit term "?"
                ++idx; target.print(" ? ")
                # Recursive Visit value-expr
                this.visit_value_expr(nodes[idx++].nodes)
                # Visit term ":"
                ++idx; target.print(" : ")
                # Recursive Visit cond-expr
                this.visit_cond_expr(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ":")
                matched = true
                # Visit term ":"
                ++idx; target.print(" : ")
                # Recursive Visit value-expr
                this.visit_value_expr(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_decl_stmts(nodes)
        var idx = 0
        ++indent
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "declaration")
            # Recursive Visit declaration
            this.visit_declaration(nodes[idx++].nodes)
            # Repeat
            while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "endl")
                # Visit endl token
                ++idx
            end
        end
        --indent
    end
    function visit_import_list(nodes)
        var idx = 0, wildcard = false
        target.print("import ")
        # Recursive Visit module-list
        stack.push_front(new module_type)
        this.visit_module_list(nodes[idx++].nodes)
        var ecsx = null
        if !stack.front.list.empty()
            ecsx = find_ecsx(stack.front.list.front.data)
            if stack.front.list.back.data == "*"
                stack.front.list.pop_back()
                wildcard = true
                var str = "; using "
                foreach it in stack.front.list
                    str += it.data + "."
                end
                str.cut(1)
                target.print(str)
                stack.front.list.clear()
            else
                stack.front.list.pop_front()
                foreach it in stack.front.list do target.print("." + it.data) 
            end
        end
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "as")
            if wildcard
                error(nodes[idx].pos, "Can not bind name alias to wildcard symbol.")
            end
            # Visit term "as"
            ++idx; target.print(" as ")
            # Visit id token
            link alias = nodes[idx++].data
            target.print(alias)
            if ecsx != null
                ecsx[0] = alias
            end
        else
            if !stack.front.list.empty()
                target.print(" as " + stack.front.list.back.data)
            end
        end
        if ecsx != null
            ecsx_hook.insert(ecsx...)
        end
        stack.pop_front()
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
            # Visit term ","
            ++idx; println("", nodes[idx - 1].pos)
            # Recursive Visit import-list
            this.visit_import_list(nodes[idx++].nodes)
        end
    end
    function visit_throw_stmt(nodes)
        var idx = 0
        # Visit term "throw"
        ++idx; target.print("throw ")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "expr")
            target.print(ecs_prefix + "ecs.throw_exception(")
            # Recursive Visit expr
            this.visit_expr(nodes[idx++].nodes)
            target.print(")")
        else
            target.print("runtime.exception(\"__ecs_except__\")")
        end
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_endline(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "endl")
                matched = true
                # Visit endl token
                ++idx; println("", {0, nodes.front.pos[1] - 1})
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ";")
                matched = true
                # Visit term ";"
                ++idx; println("", nodes.front.pos)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_try_stmt(nodes)
        var idx = 0
        # Visit term "try"
        ++idx; target.print("try ")
        # Visit endl token
        ++idx; println("", nodes.front.pos)
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
        stack.push_front("try")
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "catch-stmt")
            stack.push_front(new catch_type)
            # Recursive Visit catch-stmt
            this.visit_catch_stmt(nodes[idx++].nodes)
            # Recursive Visit stmts
            stack.front.body = nodes[idx++].nodes
            # this.visit_stmts(nodes[idx++].nodes)
        end
        print_indent()
        println("catch __ecs_except__", nodes.front.pos)
        ++indent
        var default_catch = null
        print_indent()
        println("var __ecs_catch__ = false", nodes.front.pos)
        print_indent()
        println("if __ecs_except__.what == \"__ecs_except__\"", nodes.front.pos)
        ++indent
        while typeid stack.front != typeid string || stack.front != "try"
            var dat = stack.pop_front()
            if dat.type == null
                if default_catch != null
                    error(dat.pos, "Reduplicated generic catch statement.")
                end
                default_catch = dat
                continue
            else
                print_indent()
                var type_id = get_id_of_visit_expr(dat.type)
                if type_id != null && ecs.special_type.exist(type_id)
                    println("if !__ecs_catch__ && " + ecs_prefix + "ecs.type_validator.__" + type_id + "(" + ecs_prefix + "ecs.current_except)", dat.pos)
                else
                    target.print("if !__ecs_catch__ && typeid " + ecs_prefix + "ecs.current_except == typeid(")
                    this.visit_visit_expr(dat.type)
                    println(")", dat.pos)
                end
            end
            ++indent
            print_indent()
            println("__ecs_catch__ = true", dat.pos)
            print_indent()
            println("var " + dat.id + " = " + ecs_prefix + "ecs.get_exception()", dat.pos)
            --indent
            this.visit_stmts(dat.body)
            print_indent()
            println("end", dat.pos)
        end
        --indent
        print_indent()
        println("end", nodes.front.pos)
        if default_catch != null
            print_indent()
            println("if !__ecs_catch__", default_catch.pos)
            ++indent
            print_indent()
            println("link " + default_catch.id + " = __ecs_except__", default_catch.pos)
            --indent
            this.visit_stmts(default_catch.body)
            print_indent()
            println("end", default_catch.pos)
        end
        --indent
        # Visit term "end"
        print_indent()
        println("end", {0, nodes.back.pos[1] - 1})
    end
    function visit_function_stmt(nodes)
        var idx = 0
        stack.push_front("function")
        # Visit term "function"
        ++idx; target.print("function ")
        # Visit id token
        target.print(nodes[idx++].data)
        # Visit term "("
        ++idx; target.print("(")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "argument-list")
            # Recursive Visit argument-list
            this.visit_argument_list(nodes[idx++].nodes, true)
        end
        # Visit term ")"
        ++idx; target.print(")")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "override")
            # Visit term "override"
            ++idx; target.print(" override")
        end
        println("", nodes.front.pos)
        ++indent
        while typeid stack.front != typeid string || stack.front != "function"
            link map = stack.front.second
            if map.exist("pass-by-value")
                print_indent()
                println(stack.front.first + " := clone(" + stack.front.first + ")", nodes.front.pos)
            end
            if map.exist("check-type")
                print_indent()
                var type_id = get_id_of_visit_expr(map["check-type"])
                if type_id != null && ecs.special_type.exist(type_id)
                    println(ecs_prefix + "ecs.check_type_s(\"" + stack.front.first + "\", " + stack.front.first + ", " + ecs_prefix + "ecs.type_validator.__" + type_id + ")", nodes.front.pos)
                else
                    target.print(ecs_prefix + "ecs.check_type(\"" + stack.front.first + "\", " + stack.front.first + ", ")
                    this.visit_visit_expr(map["check-type"])
                    println(")", nodes.front.pos)
                end
            end
            stack.pop_front()
        end
        stack.pop_front()
        --indent
        # Recursive Visit function-body
        this.visit_function_body(nodes[idx++].nodes)
    end
    function visit_function_body(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "{")
                matched = true
                # Visit term "{"
                ++idx
                # Recursive Visit stmts
                this.visit_stmts(nodes[idx++].nodes)
                # Visit term "}"
                ++idx; println("end", {0, nodes.back.pos[1] - 1})
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "endl")
                matched = true
                # Visit endl token
                ++idx
                # Recursive Visit stmts
                this.visit_stmts(nodes[idx++].nodes)
                # Visit term "end"
                print_indent()
                println("end", {0, nodes.back.pos[1] - 1})
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_loop_stmt(nodes)
        var idx = 0
        # Visit term "loop"
        ++idx; target.print("loop")
        # Visit endl token
        ++idx; println("", nodes.front.pos)
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
        print_indent()
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "until-stmt")
                matched = true
                # Recursive Visit until-stmt
                this.visit_until_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "end")
                matched = true
                # Visit term "end"
                println("end", {0, nodes.back.pos[1] - 1})
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_control_stmt(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "break")
                matched = true
                # Visit term "break"
                ++idx; target.print("break")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "continue")
                matched = true
                # Visit term "continue"
                ++idx; target.print("continue")
            end
            if !matched
            	# Error
            	return
            end
        end
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_logic_or_expr(nodes)
        var idx = 0
        # Recursive Visit logic-and-expr
        this.visit_logic_and_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "||" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "or")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "||")
                    matched = true
                    # Visit term "||"
                    ++idx; target.print(" || ")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "or")
                    matched = true
                    # Visit term "or"
                    ++idx; target.print(" or ")
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit logic-or-expr
            this.visit_logic_or_expr(nodes[idx++].nodes)
        end
    end
    function visit_package_stmt(nodes)
        var idx = 0
        if is_package
            error(nodes[1].pos, "Multiple definition of package name.")
        end
        is_package = true
        # Visit term "package"
        ++idx; target.print("package ")
        # Visit id token
        var id = nodes[idx++].data
        ecs_prefix = id + "_"
        target.print(id)
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_until_stmt(nodes)
        var idx = 0
        # Visit term "until"
        ++idx; target.print("until ")
        # Recursive Visit basic-expr
        this.visit_basic_expr(nodes[idx++].nodes)
        # Visit endl token
        println("", nodes.front.pos)
    end
    function visit_equal_expr(nodes)
        var idx = 0
        if nodes.size > 1 && typeid nodes[1] == typeid parsergen.token_type && (nodes[1].data == "is" || nodes[1].data == "not")
            var type_id = get_id_of_equal_expr(nodes[2].nodes)
            if type_id != null && ecs.special_type.exist(type_id)
                if nodes[1].data == "not"
                    target.print("!")
                end
                target.print(ecs_prefix + "ecs.type_validator.__" + type_id + "(")
                this.visit_relat_expr(nodes[0].nodes)
                target.print(")")
            else
                target.print("typeid(")
                this.visit_relat_expr(nodes[0].nodes)
                if nodes[1].data == "is"
                    target.print(") == typeid(")
                else
                    target.print(") != typeid(")
                end
                this.visit_equal_expr(nodes[2].nodes)
                target.print(")")
            end
        else
            # Recursive Visit relat-expr
            this.visit_relat_expr(nodes[idx++].nodes)
            # Optional
            if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "==" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "!=")
                # Condition
                block
                    var matched = false
                    if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "==")
                        matched = true
                        # Visit term "=="
                        ++idx; target.print(" == ")
                    end
                    if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "!=")
                        matched = true
                        # Visit term "!="
                        ++idx; target.print(" != ")
                    end
                    if !matched
                	    # Error
                	    return
                    end
                end
                # Recursive Visit equal-expr
                this.visit_equal_expr(nodes[idx++].nodes)
            end
        end
    end
    function visit_unary_op(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "typeid")
                matched = true
                # Visit term "typeid"
                ++idx; target.print("typeid ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "++")
                matched = true
                # Visit term "++"
                ++idx; target.print("++")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "--")
                matched = true
                # Visit term "--"
                ++idx; target.print("--")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "*")
                matched = true
                # Visit term "*"
                ++idx; target.print("*")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "&")
                matched = true
                # Visit term "&"
                ++idx; target.print("&")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "-")
                matched = true
                # Visit term "-"
                ++idx; target.print("-")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "!")
                matched = true
                # Visit term "!"
                ++idx; target.print("!")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "not")
                matched = true
                # Visit term "not"
                ++idx; target.print("not ")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_var_def(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "var-bind")
                matched = true
                # Recursive Visit var-bind
                this.visit_var_bind(nodes[idx++].nodes)
                # Visit term "="
                ++idx; target.print(" = ")
                # Recursive Visit basic-expr
                this.visit_basic_expr(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "var-list")
                matched = true
                # Recursive Visit var-list
                this.visit_var_list(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_expr_stmt(nodes)
        var idx = 0
        # Recursive Visit expr
        this.visit_expr(nodes[idx++].nodes)
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_fcall(nodes)
        var idx = 0
        # Visit term "("
        ++idx; target.print("(")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "expr")
            # Recursive Visit expr
            this.visit_expr(nodes[idx++].nodes)
        end
        # Visit term ")"
        ++idx; target.print(")")
    end
    function visit_logic_and_expr(nodes)
        var idx = 0
        # Recursive Visit equal-expr
        this.visit_equal_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "&&" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "and")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "&&")
                    matched = true
                    # Visit term "&&"
                    ++idx; target.print(" && ")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "and")
                    matched = true
                    # Visit term "and"
                    ++idx; target.print(" and ")
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit logic-and-expr
            this.visit_logic_and_expr(nodes[idx++].nodes)
        end
    end
    function gen_internal()
        for i = 0, i < lambda_list.size, ++i
            indent = 1
            link dat = lambda_list[i]
            println("struct __" + ecs_prefix + "ecs_lambda_impl_" + to_string(i + 1) + "__", dat.pos)
            foreach it in dat.capture_list
                print_indent()
                println("var " + it.first + " = null", dat.pos)
            end
            print_indent()
            target.print("function construct(")
            if !dat.capture_list.empty()
                var str = new string
                foreach it in dat.capture_list
                    str += "_" + it.first + ", "
                end
                str.cut(2)
                target.print(str)
            end
            println(")", dat.pos)
            ++indent
            foreach it in dat.capture_list
                print_indent()
                if it.second
                    println("this." + it.first + " = _" + it.first, dat.pos)
                else
                    println("this." + it.first + " := _" + it.first, dat.pos)
                end
            end
            --indent
            print_indent()
            println("end", dat.pos)
            print_indent()
            target.print("function call(")
            if !dat.argument_list.empty()
                var str = new string
                foreach it in dat.argument_list
                    if it.second.exist("vargs")
                        str += "..." + it.first + ", "
                    else
                        str += it.first + ", "
                    end
                end
                str.cut(2)
                target.print(str)
            end
            println(")", dat.pos)
            ++indent
            print_indent()
            println("link self = this.call", dat.pos)
            foreach it in dat.argument_list
                link map = it.second
                if map.exist("pass-by-value")
                    print_indent()
                    println(it.first + " := clone(" + it.first + ")", dat.pos)
                end
                if map.exist("check-type")
                    print_indent()
                    var type_id = get_id_of_visit_expr(map["check-type"])
                    if type_id != null && ecs.special_type.exist(type_id)
                        println(ecs_prefix + "ecs.check_type_s(\"" + it.first + "\", " + it.first + ", " + ecs_prefix + "ecs.type_validator.__" + type_id + ")", dat.pos)
                    else
                        target.print(ecs_prefix + "ecs.check_type(\"" + it.first + "\", " + it.first + ", ")
                        this.visit_visit_expr(map["check-type"])
                        println(")", dat.pos)
                    end
                end
            end
            if dat.body_stmts != null
                foreach it in dat.body_stmts
                    this.visit_statement(it)
                end
            end
            if dat.body_expr != null
                print_indent()
                target.print("return ")
                this.visit_cond_expr(dat.body_expr)
                println("", dat.pos)
            end
            --indent
            print_indent()
            println("end", dat.pos)
            println("end", dat.pos)
        end
    end
    function repl_header()
        return "import ecs\nimport sdk_extension as ecs_sdk\necs_sdk.extend_type(array, \"ecs_slice_ext\", ecs.ecs_slice_ext)\n"
    end
    function repl_run(ast)
        var buff = new iostream.char_buff
        target = buff.get_ostream()
        try
            visit_begin(ast.nodes)
        catch e
            if e.what == "ECS_ERROR"
                lambda_list = new array
                stack = new array
                indent = -1
                return null
            end
        end
        var header = new iostream.char_buff
        target = header.get_ostream()
        gen_internal()
        return to_string(header) + to_string(buff)
    end
    function run(name, ast)
        var buff = new iostream.char_buff
        target = buff.get_ostream()
        try
            visit_begin(ast.nodes)
        catch e
            if e.what == "ECS_ERROR"
                system.exit(0)
            end
        end
        var file_name = name + (is_package ? ".csp" : ".csc")
        target = iostream.ofstream(file_name)
        var file_dbg_info = new array
        swap(file_dbg_info, dbg_line_map)
        if !is_package
            println("#!/usr/bin/env cs", null)
        end
        if !minmal
            println("# Generated by Extended CovScript Compiler", null)
            println("# DO NOT MODIFY", null)
            target.print("# Date: " + to_string(runtime.local_time()))
            dbg_line_map.push_back("-")
        end
        foreach it in custom_header
            println(it, null)
        end
        if is_package
            println("import ecs as " + ecs_prefix + "ecs", null)
        else
            println("import ecs", null)
        end
        if slice_ext
            println("import sdk_extension as " + ecs_prefix + "ecs_sdk", null)
            println(ecs_prefix + "ecs_sdk.extend_type(array, \"ecs_slice_ext\", " + ecs_prefix + "ecs.ecs_slice_ext)", null)
        end
        gen_internal()
        target.print(buff)
        foreach it in file_dbg_info do dbg_line_map.push_back(it)
        return file_name
    end
end