# Bootstrap of Extended Covariant Script Generator v1.4.2
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Copyright (C) 2017-2023 Michael Lee(李登淳)
#
# Email:   lee@unicov.cn, mikecovlee@163.com
# Github:  https://github.com/mikecovlee
# Website: http://covscript.org.cn

package ecs_bootstrap

import parsergen, ecs_parser, ecs_generator, codec, regex

var wrapper_ver = "1.4.2"

function show_version()
@begin
    system.out.println(
        "Version: " + ecs_generator.ecs_info.version + ", Wrapper " + wrapper_ver + "\n" +
        "Copyright (C) 2017-2023 Michael Lee. All rights reserved.\n" +
        "Please visit http://covscript.org.cn/ for more information.\n\n" +
        "Metadata:\n" +
        "  STD Version: " + ecs_generator.ecs_info.std_version + "\n"
    )
@end
    system.exit(0)
end

function show_help()
@begin
    system.out.println(
        "Usage: ecs [options...] <FILE> [arguments...]\n\n" +
        "Options:\n" +
        "    Option       Function\n" +
        "   -h            Show help information\n" +
        "   -v            Show version infomation\n" +
        "   -f            Disable compile cache\n" +
        "   -m            Disable beautify\n" +
        "   -c            Check grammar only\n" +
        "   -g            Generate cSYM info\n" +
        "   -d            Run debugger\n" +
        "   -u <CHARSET>  Set unicode charset\n" +
        "                 CHARSET = {\"UTF8\", \"GBK\"}\n" +
        "   -i <PATH>     Set import path\n" +
        "   -o <PATH>     Set output path\n" +
        "   -- <ARGS>     Pass parameters to CovScript\n"
    )
@end
    system.exit(0)
end

var compiler_args = new string
var file_name = new string
var arguments = new string
var executor = "cs "
var no_hash = false
var csx_path = null
var unicode = null
var minmal = false
var no_run = false
var splash = null
var output = null
var csym = false

function process_args(cmd_args)
    var index = 1
    while index < cmd_args.size && cmd_args[index][0] == '-'
        switch cmd_args[index]
            default
                system.out.println("Error: Unknown option \"" + cmd_args[index] + "\"")
                system.exit(0)
            end
            case "-v"
                show_version()
            end
            case "-h"
                show_help()
            end
            case "-f"
                no_hash = true
            end
            case "-m"
                minmal = true
            end
            case "-c"
                no_run = true
            end
            case "-g"
                no_hash = true
                csym = true
            end
            case "-d"
                executor = "cs_dbg -s "
                no_hash = true
                csym = true
                @begin
                splash =
                    "Extended Covariant Script Debugger\nVersion: " + ecs_generator.ecs_info.version + ", Wrapper " + wrapper_ver + "\n" +
                    "Copyright (C) 2017-2023 Michael Lee. All rights reserved.\n" +
                    "Please visit <http://covscript.org.cn/> for more information."
                @end
            end
            case "-u"
                if index == cmd_args.size - 1
                    system.out.println("Error: Option \"-u\" not completed. Usage: \"ecs -u <CHARSET>\"")
                    system.exit(0)
                end
                unicode = cmd_args[++index]
            end
            case "-i"
                if index == cmd_args.size - 1
                    system.out.println("Error: Option \"-i\" not completed. Usage: \"ecs -i <PATH>\"")
                    system.exit(0)
                end
                csx_path = cmd_args[++index]
            end
            case "-o"
                if index == cmd_args.size - 1
                    system.out.println("Error: Option \"-o\" not completed. Usage: \"ecs -o <PATH>\"")
                    system.exit(0)
                end
                output = cmd_args[++index]
                no_run = true
            end
            case "--"
                if index == cmd_args.size - 1
                    system.out.println("Error: Option \"--\" not completed. Usage: \"ecs -- <ARGS>\"")
                    system.exit(0)
                end
                compiler_args = cmd_args[++index]
            end
        end
        ++index
    end
    if index == cmd_args.size
        system.out.println("Error: no input file.")
        system.exit(0)
    end
    file_name = cmd_args[index++]
    while index < cmd_args.size
        arguments += " " + cmd_args[index++] 
    end
end

@begin
var codecvt_map = {
    "UTF8": ([](unicode)->new unicode.codecvt.utf8),
    "GBK": ([](unicode)->new unicode.codecvt.gbk)
}.to_hash_map()
@end

var ecs_reg = regex.build("^(.*)\\.ecs$")
var lcs_reg = regex.build("^(.*)\\.(csc|csp)$")

function match(reg, str)
    return !reg.match(str).empty()
end

function process_path(str)
    if system.is_platform_windows()
        var s = str
        foreach i in range(s.size)
            if s[i] == '/'
                s.assign(i, '\\')
            end
        end
        return move(s)
    else
        return str
    end
end

function main(cmd_args)
    process_args(cmd_args)
    if !system.file.exist(file_name) || !match(regex.build(ecs_parser.grammar.ext), file_name)
        system.out.println("Error: invalid input file.")
        system.exit(0)
    end
    var file_hash = null
    if !no_hash
        file_hash = codec.sha256.hash_file(file_name) + ".ecs_cache"
        if output == null
            minmal = true
            if system.file.exist("./.ecs_output/" + file_hash)
                var ifs = iostream.ifstream("./.ecs_output/" + file_hash)
                var name = ifs.getline()
                var mtime = ifs.getline().to_number()
                if mtime == system.file.mtime(file_name)
                    system.exit(no_run ? 0 : system.run(process_path(executor + compiler_args + " " + name + arguments)))
                end
            end
        end
    end
    var parser = new parsergen.generator
    if unicode != null
        parser.add_grammar("ecs-lang", ecs_parser.grammar)
        var unicode_ext = context.import(runtime.get_import_path(), "unicode")
        if unicode_ext == null
            system.out.println("Error: unicode extension not installed yet.")
            system.out.println("Run \'cspkg install extension --yes\' to enable unicode support.")
            system.exit(0)
        end
        var cvt_name = unicode.toupper()
        if !codecvt_map.exist(cvt_name)
            system.out.println("Error: unknown unicode charset \"" + cvt_name + "\".")
            system.exit(0)
        end
        parser.unicode_cvt = codecvt_map.at(cvt_name)(unicode_ext)
        ecs_parser.grammar.lex = ecs_parser.get_lexical([](str)->unicode_ext.build_wregex(parser.unicode_cvt.local2wide(str)))
    end
    parser.add_grammar("ecs-lang", ecs_parser.grammar)
    parser.from_file(file_name)
    if parser.ast != null
        if match(lcs_reg, file_name)
            if csx_path != null
                compiler_args += " -i " + csx_path
            end
            system.exit(no_run ? 0 : system.run(process_path(executor + compiler_args + " " + file_name + arguments)))
        end
        var codegen = new ecs_generator.generator
        if csx_path != null
            compiler_args += " -i " + csx_path
            codegen.ecsx_path = csx_path.split({system.path.delimiter})
        end
        codegen.code_buff = parser.code_buff
        codegen.file_name = file_name
        codegen.minmal = minmal
        if unicode != null
            codegen.custom_header.push_back("@charset: " + unicode.tolower())
        end
        if output != null
            var result = ecs_reg.match(file_name)
            if !result.empty()
                var name = output + system.path.separator + result.str(1).split({'\\', '/'})[-1]
                var target_name = codegen.run(name, parser.ast)
                if csym
                    var csym_ofs = iostream.ofstream(name + ".csym")
                    var dbg_info = "#$cSYM/1.0(" + file_name + "):"
                    foreach it in codegen.dbg_line_map do dbg_info += it + ","
                    dbg_info.cut(1)
                    csym_ofs.println(dbg_info)
                    foreach it in parser.code_buff do csym_ofs.println(it)
                end
                if !no_hash
                    iostream.ofstream("./.ecs_output/" + file_hash).println(target_name)
                end
                if splash != null
                    system.out.println(splash)
                end
                system.exit(no_run ? 0 : system.run(process_path(executor + compiler_args + " " + target_name + arguments)))
            end
        else
            system.path.mkdir_p("./.ecs_output/")
            var name = "./.ecs_output/" + codec.sha256.hash_str(file_name)
            var target_name = codegen.run(name, parser.ast)
            if csym
                compiler_args += " -g " + name + ".csym"
                var csym_ofs = iostream.ofstream(name + ".csym")
                var dbg_info = "#$cSYM/1.0(" + file_name + "):"
                foreach it in codegen.dbg_line_map do dbg_info += it + ","
                dbg_info.cut(1)
                csym_ofs.println(dbg_info)
                foreach it in parser.code_buff do csym_ofs.println(it)
            end
            if !no_hash
                var ofs = iostream.ofstream("./.ecs_output/" + file_hash)
                ofs.println(target_name)
                ofs.println(system.file.mtime(file_name))
            end
            if splash != null
                system.out.println(splash)
            end
            system.exit(no_run ? 0 : system.run(process_path(executor + compiler_args + " " + target_name + arguments)))
        end
    end
end