# Covariant Script AST Visitor Generator v1.1.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Copyright (C) 2017-2023 Michael Lee(李登淳)
#
# Email:   lee@unicov.cn, mikecovlee@163.com
# Github:  https://github.com/mikecovlee
# Website: http://covscript.org.cn

package visitorgen

import parsergen

@begin
var header =
"# Generated by CovScript AST Visitor Generator\n" +
"# Date: " + to_string(runtime.local_time()) +
"package ast_visitor\n" +
"import parsergen\n" +
"class main\n" +
"    var target = system.out\n" +
"    var indent = -1\n" +
"    function print_indent()\n" +
"        foreach i in range(indent) do target.print(\'\\t\')\n" +
"    end"
@end

@begin
var tail =
"    function run(os, ast)\n" +
"        this.target = os\n" +
"        this.visit_begin(ast.nodes)\n" +
"    end\nend"
@end

class visitor_generator
    var target = system.out
    var syntax = null
    var indent = 1
    function print(text)
        foreach i in range(indent*4) do target.print(' ')
        target.print(text)
    end
    function println(text)
        foreach i in range(indent*4) do target.print(' ')
        target.println(text)
    end
    function get_prefix_stx(stx)
        switch stx.type
            case parsergen.syntax_type.nlook
                return null
            end
            case parsergen.syntax_type.token
                return {stx}
            end
            case parsergen.syntax_type.term
                return {stx}
            end
            case parsergen.syntax_type.ref
                return this.get_prefix(stx.data)
            end
        end
    end
    function get_prefix(seq)
        var data = new array
        var it = seq.begin
        loop
            switch it.data.type
                case parsergen.syntax_type.token
                    data.push_back(it.data)
                    break
                end
                case parsergen.syntax_type.term
                    data.push_back(it.data)
                    break
                end
                case parsergen.syntax_type.nlook
                    it.next()
                end
                case parsergen.syntax_type.ref
                    data.push_back(it.data)
                    break
                end
                case parsergen.syntax_type.repeat
                    var product = get_prefix(it.data.data)
                    if product != null
                        foreach stx in product do data.push_back(move(stx))
                    end
                    break
                end
                case parsergen.syntax_type.opt
                    var product = get_prefix(it.data.data)
                    if product != null
                        foreach stx in product do data.push_back(move(stx))
                    end
                    it.next()
                end
                case parsergen.syntax_type.cond
                    foreach stx in it.data.data
                        var product = get_prefix(stx.data)
                        if product != null
                            foreach stx in product do data.push_back(move(stx))
                        end
                    end
                    break
                end
            end
        end
        if !data.empty()
            return data
        else
            return null
        end
    end
    function gen_match(stx)
        switch stx.type
            case parsergen.syntax_type.term
                target.print("typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == \"" + stx.data + "\"")
            end
            case parsergen.syntax_type.token
                target.print("typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == \"" + stx.data + "\"")
            end
            case parsergen.syntax_type.ref
                target.print("typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == \"" + stx.data + "\"")
            end
        end
    end
    function gen_syntax(s)
        switch s.type
            case parsergen.syntax_type.token
                println("# Visit " + s.data + " token")
                println("target.print(nodes[idx++].data)")
            end
            case parsergen.syntax_type.term
                println("# Visit term \"" + s.data + "\"")
                println("++idx; target.print(\"" + s.data + "\")")
            end
            case parsergen.syntax_type.ref
                var name = s.data
                for i = 0, i < name.size, ++i
                    if name[i] == '-'
                        name.assign(i, '_')
                    end
                end
                println("# Recursive Visit " + s.data)
                println("this.visit_" + name + "(nodes[idx++].nodes)")
            end
            case parsergen.syntax_type.repeat
                println("# Repeat")
                var prefix = get_prefix(s.data)
                if prefix != null
                    var beg = prefix.begin
                    print("while idx < nodes.size && (")
                    gen_match(beg.data)
                    loop
                        beg.next()
                        if beg != prefix.end
                            target.print(" || ")
                            gen_match(beg.data)
                        else
                            break
                        end
                    end
                    target.println(")")
                else
                    println("# TODO")
                    println("while idx < nodes.size && (true)")
                end
                ++indent
                foreach it in s.data
                    gen_syntax(it)
                end
                --indent
                println("end")
            end
            case parsergen.syntax_type.opt
                println("# Optional")
                var prefix = get_prefix(s.data)
                if prefix != null
                    var beg = prefix.begin
                    print("if idx < nodes.size && (")
                    gen_match(beg.data)
                    loop
                        beg.next()
                        if beg != prefix.end
                            target.print(" || ")
                            gen_match(beg.data)
                        else
                            break
                        end
                    end
                    target.println(")")
                else
                    println("# TODO")
                    println("if idx < nodes.size && (true)")
                end
                ++indent
                foreach it in s.data
                    gen_syntax(it)
                end
                --indent
                println("end")
            end
            case parsergen.syntax_type.cond
                println("# Condition")
                println("block")
                ++indent
                println("var matched = false")
                foreach seq in s.data
                    var prefix = get_prefix(seq.data)
                    if prefix != null
                        var beg = prefix.begin
                        print("if !matched && (")
                        gen_match(beg.data)
                        loop
                            beg.next()
                            if beg != prefix.end
                                target.print(" || ")
                                gen_match(beg.data)
                            else
                                break
                            end
                        end
                        target.println(")")
                    else
                        println("# TODO")
                        println("if !matched && true")
                    end
                    ++indent
                    println("matched = true")
                    foreach it in seq.data
                        gen_syntax(it)
                    end
                    --indent
                    println("end")
                end
                println("if !matched")
                println("\t# Error")
                println("\treturn")
                println("end")
                --indent
                println("end") 
            end
        end
    end
    function run(os, stx)
        target = os
        syntax = stx
        target.println(header)
        foreach it in stx
            var name = it.first
            for i = 0, i < name.size, ++i
                if name[i] == '-'
                    name.assign(i, '_')
                end
            end
            println("function visit_" + name + "(nodes)")
            ++indent
            println("var idx = 0")
            foreach s in it.second
                gen_syntax(s)
            end
            --indent
            println("end")
        end
        target.println(tail)
    end
end