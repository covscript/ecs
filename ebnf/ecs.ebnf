begin_ ::= stmts_ ;

ignore_ ::= { ENDL } ;

endline_ ::= ENDL | ';' ;

stmts_ ::= {statement_ {ENDL}} ;

decl_stmts_ ::= {declaration_ {ENDL}} ;

endblock_ ::= end_stmt_ | else_stmt_ | until_stmt_ | catch_stmt_ ;

statement_ ::= prep_stmt_ | package_stmt_ | import_stmt_ | var_stmt_ | block_stmt_ | namespace_stmt_ | using_stmt_ | if_stmt_ | switch_stmt_ | while_stmt_ | loop_stmt_ | for_stmt_ | foreach_stmt_ | control_stmt_ | function_stmt_ | return_stmt_ | try_stmt_ | throw_stmt_ | class_stmt_ | expr_stmt_ ;

declaration_ ::= prep_stmt_ | namespace_stmt_ | var_stmt_ | using_stmt_ | function_stmt_ | class_stmt_ ;

prep_stmt_ ::= PREP ENDL ;

package_stmt_ ::= 'package' ID endline_ ;

import_stmt_ ::= 'import' import_list_ endline_ ;

module_list_ ::= ID ['.' ('*' | module_list_ )] ; 

import_list_ ::= module_list_ ['as' ID ] [',' import_list_ ] ;

var_def_ ::= var_bind_ '=' basic_expr_ | var_list_;

var_stmt_ ::= ('var' | 'link' | 'constant') var_def_ endline_ ;

var_bind_ ::= '(' var_bind_list_ {',' var_bind_list_} ')' ;

var_bind_list_ ::= ID | '...' | var_bind_ ;

var_list_ ::= ID '=' single_expr_ [',' var_list_];

block_stmt_ ::= 'block' ENDL stmts_ 'end' ENDL;

namespace_stmt_ ::= 'namespace' ID ENDL decl_stmts_ 'end' ENDL;

using_stmt_ ::= 'using' using_list_ endline;

using_list_ ::= module_list_ [',' using_list_];

if_stmt_ ::= 'if' basic_expr_ ENDL stmts_ {else_stmt_ stmts_ 'end' ENDL};

else_stmt_ ::= 'else' ['if' basic_expr_] ENDL ;

switch_stmt_ ::= 'switch' basic_expr_ ENDL switch_stmts_ 'end' ENDL;

switch_stmts_ ::= {switch_case_ | switch_default_} {ENDL};

switch_case_ ::= 'case' logic_or_expr_ ENDL stmts_ 'end' ENDL;

switch_default_ ::= 'default' ENDL stmts_ 'end' ENDL;

while_stmt_ ::= 'while' basic_expr_ ENDL stmts_ 'end' ENDL;

loop_stmt_ ::= 'loop' ENDL stmts_ (until_stmt_ | 'end' | ENDL);

until_stmt_ ::= 'until' basic_expr_ ENDL;

for_stmt_ ::= 'for' [var_def_] (';' | ',') [basic_expr_] (';' | ',') [basic_expr_] for_body_;

foreach_stmt_ ::= 'foreach' ID 'in' basic_expr_ for_body_;

for_body_ ::= ('do' basic_expr_ endline_ | ENDL stmts_ 'end' ENDL);

function_stmt_ ::= 'function' ID '(' [argument_list_] ')' ['override'] function_body_;

function_body_ ::= ('{' stmts_ '}' | ENDL stmts_ 'end' ENDL);

return_stmt_ ::= 'return' [expr_] endline_;

try_stmt_ ::= 'try' ENDL stmts_ {catch_stmt_ stmts_} 'end' ENDL;

catch_stmt_ ::= 'catch' ID [':' visit_expr_]  ENDL;

throw_stmt_ ::= 'throw' [expr_] endline_;

class_stmt_ ::= ('class' | 'struct') ID ['extends' visit_expr_] ENDL decl_stmts_ 'end' ENDL;

control_stmt_ ::= ('break' | 'continue') endline_;

expr_stmt_ ::= expr_ endline_;

end_stmt_ ::= 'end' ENDL;

expr_ ::= single_expr_ [',' expr_];

single_expr_ ::= lambda_expr_ | basic_expr_;

basic_expr_ ::= var_bind_ '=' cond_expr_ | cond_expr_ [asi_op_ single_expr_];

asi_op_ ::= '=' | ':=' | '+=' | '-=' | '*=' | '/=' | '%=' | '^=' ;

lambda_expr_ ::= '[' [capture_list_] ']' '(' [argument_list_] ')' lambda_body_;

capture_list_ ::= ['='] ID {',' capture_list_} ;

argument_list_ ::= '...' ID | ['='] ID [':'] visit_expr_ {',' argument_list_};

lambda_body_ ::= '{' {statement_ {ENDL}} '}' | '->' cond_expr_;

cond_expr_ ::= logic_or_expr_ [cond_postfix_];

cond_postfix_ ::= '?' logic_or_expr_ ':' cond_expr_ | ':' logic_or_expr_;

logic_or_expr_ ::= logic_and_expr_ [('||' | 'or') logic_or_expr_];

logic_and_expr_ ::= equal_expr_ [('&&' | 'and') logic_and_expr_];

equal_expr_ ::= relat_expr_ [('==' | '!=') equal_expr_];

relat_expr_ ::= add_expr_ [('>' | '<' | '>=' | '<=') relat_expr_];

add_expr_ ::= mul_expr_ [('+' | '-') add_expr_];

mul_expr_ ::= unary_expr_ [('*' | '/' | '%' | '^') mul_expr_];

unary_expr_ ::= unary_op_ unary_expr_ | ('new' | 'gcnew') unary_expr_ [array_] | prim_expr_ [postfix_expr_];

unary_op_ ::= 'typeid' | '++' | '--' | '*' | '&' | '-' | '!';

postfix_expr_ ::= ('++' | '--' | '...')  [postfix_expr_];

prim_expr_ ::= visit_expr_ | constant_ ;

visit_expr_ ::= object_ [ ('->' | '.') visit_expr_ ];

object_ ::= array_ [index_] | STR [index_] | 'local' | 'global' | element_ | CHAR;

element_ ::= (ID | '(' single_expr_ ')') {fcall_ | index_};

constant_ ::= NUM | 'null' | 'true' | 'false';

array_ ::= '{' [expr_] '}';

fcall_ ::= '(' [expr_] ')';

index_ ::= '[' basic_expr_ ']';