begin ::= stmts ;

ignore ::= { ENDL } ;

endline ::= ENDL | ';' ;

stmts ::= {statement {ENDL}} ;

decl-stmts ::= {declaration {ENDL}} ;

endblock ::= end-stmt | else-stmt | until-stmt | catch-stmt ;

statement ::= prep-stmt | package-stmt | import-stmt | var-stmt | block-stmt | namespace-stmt | using-stmt | if-stmt | switch-stmt | while-stmt | loop-stmt | for-stmt | foreach-stmt | control-stmt | function-stmt | return-stmt | try-stmt | throw-stmt | class-stmt | expr-stmt ;

declaration ::= prep-stmt | namespace-stmt | var-stmt | using-stmt | function-stmt | class-stmt ;

prep-stmt ::= PREP ENDL ;

package-stmt ::= 'package' ID endline ;

import-stmt ::= 'import' import-list endline ;

module-list ::= ID ['.' ('*' | module-list )] ; 

import-list ::= module-list ['as' ID ] [',' import-list ] ;

var-def ::= var-bind '=' basic-expr | var-list;

var-stmt ::= ('var' | 'link' | 'constant') var-def endline ;

var-bind ::= '(' var-bind-list {',' var-bind-list} ')' ;

var-bind-list ::= ID | '...' | var-bind ;

var-list ::= ID '=' single-expr [',' var-list];

block-stmt ::= 'block' ENDL stmts 'end' ENDL;

namespace-stmt ::= 'namespace' ID ENDL decl-stmts 'end' ENDL;

using-stmt ::= 'using' using-list endline;

using-list ::= module-list [',' using-list];

if-stmt ::= 'if' basic-expr ENDL stmts {else-stmt stmts} 'end' ENDL;

else-stmt ::= 'else' ['if' basic-expr] ENDL ;

switch-stmt ::= 'switch' basic-expr ENDL switch-stmts 'end' ENDL;

switch-stmts ::= {switch-case | switch-default} {ENDL};

switch-case ::= 'case' logic-or-expr ENDL stmts 'end' ENDL;

switch-default ::= 'default' ENDL stmts 'end' ENDL;

while-stmt ::= 'while' basic-expr ENDL stmts 'end' ENDL;

loop-stmt ::= 'loop' ENDL stmts (until-stmt | 'end' | ENDL);

until-stmt ::= 'until' basic-expr ENDL;

for-stmt ::= 'for' [var-def] (';' | ',') [basic-expr] (';' | ',') [basic-expr] for-body;

foreach-stmt ::= 'foreach' ID 'in' basic-expr for-body;

for-body ::= ('do' basic-expr endline | ENDL stmts 'end' ENDL);

function-stmt ::= 'function' ID '(' [argument-list] ')' ['override'] function-body;

function-body ::= ( [ENDL] '{'[ENDL] stmts '}' | ENDL stmts 'end' ENDL);

return-stmt ::= 'return' [expr] endline;

try-stmt ::= 'try' ENDL stmts {catch-stmt stmts} 'end' ENDL;

catch-stmt ::= 'catch' ID [':' visit-expr]  ENDL;

throw-stmt ::= 'throw' [expr] endline;

class-stmt ::= ('class' | 'struct') ID ['extends' visit-expr] ENDL decl-stmts 'end' ENDL;

control-stmt ::= ('break' | 'continue') endline;

expr-stmt ::= expr endline;

end-stmt ::= 'end' ENDL;

expr ::= single-expr [',' expr];

single-expr ::= lambda-expr | basic-expr;

basic-expr ::= var-bind '=' cond-expr | cond-expr [asi-op single-expr];

asi-op ::= '=' | ':=' | '+=' | '-=' | '*=' | '/=' | '%=' | '^=' ;

lambda-expr ::= '[' [capture-list] ']' '(' [argument-list] ')' lambda-body;

capture-list ::= ['='] ID {',' capture-list} ;

argument-list ::= '...' ID | ['='] ID [':' visit-expr] {',' argument-list};

lambda-body ::= '{' {statement {ENDL}} '}' | '->' cond-expr;

cond-expr ::= logic-or-expr [cond-postfix];

cond-postfix ::= '?' logic-or-expr ':' cond-expr | ':' logic-or-expr;

logic-or-expr ::= logic-and-expr [('||' | 'or' ) logic-or-expr];

logic-and-expr ::= equal-expr [('&&' | 'and') logic-and-expr];

equal-expr ::= relat-expr [('==' | '!=' | 'is' | 'not') equal-expr];

relat-expr ::= add-expr [('>' | '<' | '>=' | '<=') relat-expr];

add-expr ::= mul-expr [('+' | '-') add-expr];

mul-expr ::= unary-expr [('*' | '/' | '%' | '^') mul-expr];

unary-expr ::= unary-op unary-expr | ('new' | 'gcnew') unary-expr [array] | prim-expr [postfix-expr];

unary-op ::= 'typeid' | '++' | '--' | '*' | '&' | '-' | '!' | 'not';

postfix-expr ::= ('++' | '--' | '...')  [postfix-expr];

prim-expr ::= visit-expr | constant ;

visit-expr ::= object [ ('->' | '.') visit-expr ];

object ::= array [index] | STR [index] | 'local' | 'global' | element | CHAR;

element ::= (ID | '(' single-expr ')') {fcall | index};

constant ::= NUM | 'null' | 'true' | 'false';

array ::= '{' [expr] '}';

fcall ::= '(' [expr] ')';

index ::= '[' basic-expr ']';