# ecs

## 为保证每一步的对象合理,且便于后续改进,现针对每一步的对象系统进行总结

### parsergen

+ syntax_impl
    + boot   
    + type
    + data

    boot为first集
    用于储存描述语法规则的对象,如begin ::= statements

+ grammar
    + ext
    + lex
    + stx

    用于储存一个语言的语法规则,现包括词法规则,文法规则,翻译规则.


+ token_type
    + pos
    + type
    + data

    一个token对象,描述位置,类型以及token的值

+ lex_error
    + text
    + pos

    词法分析中的错误对象,包含错误内容与错误发生的位置

+ lexer_type
    + lexical_set
    + error_log
    + output
    + buff
    + data  
    + wpos
    + pos

    核心算法 run
    输入 lexical(词法规则, text)
    指针不断向前移动,针对每个字符做以下处理:
    若lexical_set为空(尚未读入任何数据),则分析当前字符ch:
        若ch能符合规则,则向lexical_set插入对应 '类型'
    若ch不符合任何规则,则报错
    若lexical不为空,则对lexical现有规则进行进一步匹配
    ...
    lexical_set其实是用于匹配缓存,匹配时记录已匹配的信息,便于string信息的进一步分析

    词法分析器
    lexical_set (匹配缓存)
    error_log 储存lex_error,报错用
    output tokens(array)
    buff 字符缓存,记录数据value信息
    data 输入
    wpos 记录pos位置
    pos[2]为输入的总位置,pos[0]和pos[1]用于储存行/列

+ syntax_tree
    + root
    + nodes

    语法树,root储存信息,nodes储存子结点(类似指针)

+ parse_stage
    + product
    + cursor

    product储存syntax_tree
    cursor储存遍历lex的指针位置

+ parse_error
    + cursor
    + text
    + pos

    cursor
    text为错误信息
    pos为错误位置

+ bootset_type
    + data_set
    + type_set
    
    parse用(应该是lr分析)
    预测表,分别是预测数值(如'else')或类型(如 'NUMBER')

+ parser_type
    + error_log
    + max_cursor
    + predict_cache
    + ign_bootset
    + stack
    + on_ign
    + syn
    + lex
    + log_indent
    + log


    error_log 储存错误信息(parse_error)
    max_cursor (深度?)

    predict_cache 预测表 
    ign_bootset 忽略的预测表?
    stack  分析栈 储存parse_stage
    on_ign flag
    syn
    lex
    
    log_indent 输出用辅助变量
    log

    push_stage(root)
    输入root
    stack压栈root

    pop_stage()
    (返回)stack弹栈并返回

    push_token()
    栈顶元素的product的nodes加入一个元素

    cursor()
    (返回)获取cursor位置

    eof()
    (返回)是否分析结束

    peek()
    (返回)当前分析到的元素,目的是查看

    get()
    (返回)当前分析的元素,并使指针向前移,目的是移动指针

    error(str, pos)
    生成一个错误,并加入至error_log里

    get_log()
    获取输出信息

    parse_log()
    输出log信息

    accept()
    获取栈顶元素并弹出
    将该元素压入现栈顶元素的nodes中

    merge()
    获取栈顶元素并弹出
    将该元素nodes中所有结点压至现栈顶中nodes中


    自顶向下:
    match_syntax(seq)
    对seq中每个元素进行match操作,若出现非accept的结果,则返回匹配结果,否则返回accept

    try_ignore()
    检测是否需要进行ignore的元素
    

    ignore()

    predict(set, fail_on_eof)
    返回)是否在预测分析表中

    match(it)

    
    prep_syntax()
    获取预测表
    term:token:将元素值加入预测表
    ref:将ref的first集所有元素加入该元素first集中 

    run(grammar, lex_output)
    首先获得预测表,然后push_stage("begin")表示程序开始.
    执行match_syntax开始分析

    

+ generator
    + rules
    + input
    + code_buff
    + token_buff
    + ast
    + lexer
    + parser
    + stop_on_error
    + enable_log
    + file_path

主要的程序启动函数,包括文件引入,添加文法规则等.

目前lexer部分有一定的缺陷(有些词法用正则表达逐次匹配不太适合)


### visitorgen

+ visitor_generator
    + target
    + syntax
    + indent 

    print(text) 
    输入indent后输入text信息

    println(text)
    同上+换行

    get_prefix_stx(stx)



    需要修改


### ecs_analyzer(ebnf_parser.csp)

package: ebnf_parser
import parsergen

1.提供lexical_rule
2.提供syntax_rule

接口: 提供一个grammar

目的:将提供的ecs文件生成一个文法树

暂需要确认:lexical  syntax的文法是否严谨/是否能更简

### 文法翻译(grammar_transfer)

目的:遍历文法树,序列化文法规则, 并将ebnf变为bnf文法规则

规则原理:

Ⅰ: 不变  

begin ::= statements;

prep_stmt ::= PREP ENDL;

Ⅱ: 一次变换

a: optional|

var_bind_list ::= ID | '...' | var_bind ;

-> {
    var_bind_list ::= ID;
    var_bind_list ::= '...';
    var_bind_list ::= var_bind;
}

即将由 '|' 分割的每个内容重新建立一个新的statement

b: opt()

return_stmt ::= 'return' [expr] endline

-> {
    return_stmt ::= 'return' return_stmt@0_opt_2 endline;
    return_stmt@0_rep_2 ::= NULL;
    return_stmt@0_rep_2 ::= expr;
}

将带 optional 的一块 opt 作为一个新的部分,从新命名(详见命名规则),新的两个statement依次是 
-> {
    opt ::= NULL;
    opt ::= expr;
}

c: rep{}

var_bind ::= '(' var_bind_list {',' var_bind_list} ')' ;

->{
    var_bind ::= '(' var_bind_list var_bind@0_rep_3 ')' ;
    var_bind@0_rep_3 ::= NULL ;
    var_bind@0_rep_3 ::= ',' var_bind_list var_bind@0_rep_3
}

将带 repeat 的一块 rep 作为新的一个部分,从新命名(详见命名规则),新的两个statement一次是
-> {
    rep ::= NULL;
    rep ::= expr rep; (此处expr为 ',' var_bind_list)
}

Ⅲ: 两次+变换

decl ()

control_stmt ::= ('break' | 'continue') endline ;

-> {
    control_stmt  ::= control_stmt@0_decl_1 endline ;
    control_stmt@0_decl_1  ::= 'continue' ;
    control_stmt@0_decl_1  ::= 'break' ;
}

将 declare 一块 decl 作为一个新的部分,从新命名(详见命名规则),新的部分按照一次变换规则,该括号主要目的是利用结合律改变优先级等

Ⅳ: 混合变换

一般为括号中夹带其他括号,按照顺序依次展开即可

module_list ::= ID ['.' ('*' | module_list)] ; 

-> {
    module_list  : ID module_list@0_opt_2 
    module_list@0_opt_2  : NULL 
    module_list@0_opt_2  : '.' module_list@0_opt_2@0_decl_2 
    module_list@0_opt_2@0_decl_2  : module_list 
    module_list@0_opt_2@0_decl_2  : '*' 
}

先将第一个 opt 替换为新的一块,变成
{
    module_list  : ID module_list@0_opt_2 ;
    module_list@0_opt_2  : NULL ;
    module_list@0_opt_2  : '.' ('*' | module_list) ;

}
decl中的括号按照之前的规则进行转换,即

{
    module_list@0_opt_2  : '.' module_list@0_opt_2@0_decl_2 ;
    module_list@0_opt_2@0_decl_2  : module_list ;
    module_list@0_opt_2@0_decl_2  : '*' ;
}

grammar_transfer


+ tree_type 储存一个式子的信息
    + nodes 储存节点信息
    + root 储存终结符名称
    + seq 储存?信息  (没用)


+ traversal_old_tree
    + now_name 作为缓存储存名称信息
    + now_time 储存顺序信息
    + now_tree 储存正在操作的树信息
    + root 操作正在操作的树根节点信息 ?(为什么是tree_type)
    + store_tree 缓存 ?(作用?)
    + res ?(作用?)

run(ast)
输入,树信息
root.root='%root%'   命名root
visit_begin(ast.nodes)
store_statements() 将root下每个statement存入res中


+ traversal_new_tree
    遍历输出用


原ast对象
+ root  string
+ nodes array

visit_begin()
    对nodes中每个对象进行visit_statement

visit_statement()
    储存tree
    先访问statement.non_terminal_symbol
    记录non_terminal_symbol的属性
    访问declaration
    将储存树的内容全部加入新的树中

visit_non_terminal_symbol() 
    返回值

visit_declaration() 
    访问第一个term
    若有多个term,则增加time,生成多个statement 如:
    var_bind_list ::= ID | '...' | var_bind ;
    应生成
    var_bind_list ::= ID ;
    var_bind_list ::= '...' ;
    var_bind_list ::= var_bind ;

visit_term()
    访问每个part

visit_part()
    若出现rep_part\opt_part\decl_part则需要储存当前树,并将该结点进行重新命名,然后将结点下的内容储存为若干棵新树,若是simple_part则无需特殊处理.

    关于NULL的表示??

命名规则:
    base@time_type_pos
    base:原名称,如var_bind,则改名后则为var_bind@xxxxxxx
    time:term出现次数,主要避免由|隔开的part中有相同的特殊part,导致命名重复但结果无法匹配,如:
        A ::= B [C] | D [E] ;
        若不加time,二者均重名为 A@rep_2,显然不能正确匹配,故增加time后为
        A@1_rep_2 ([C])  与 A@2_rep_2([E]) 以正确区分
    type:rep/opt/decl区分类型(其实没有并没有太大关系)
    pos: 该新树所在原表达式的位置,主要区分多个新树



visit_repeat_part()
    add_suffix_part() 将repeat_part的每个term后面都添加一个非终结符
    add_null_term()  添加null
    this.visit_declaration() 再次分析
    
    如   原为:  A ::= {B | C} D;
        则新名字为A@0_rep_1
        修改为 A ::= A@0_rep_1 D;
        A@0_rep_1 ::= C A@0_rep_1 | D A@0_rep_1 | NULL;
    然后再将该结点进行declaration分析    

visit_declaration_part()
    visit_declaration  因为只是修改优先级/结合律 故没特殊的地方

visit_alternative_part()
    add_null_term()
    visit_declaration()
    仅添加NULL即可

    如 原为 A ::= [B | C] D;
        新名字为A@0_opt_1
        修改为A ::= A@0_opt_1 D;
        A@0_opt_1 ::= C | D | NULL ;
    然后将该结点进行declaration分析

visit_simple_part() simple_part由终结符或非终结符组成,获取信息存入即可
    visit_right_non_terminal_symbol
    visit_terminal_symbol

visit_right_non_terminal_symbol()
    visit_non_terminal_symbol

visit_terminal_symbol()
    return data

store_statement


简单分析缺点:
    token的储存内容不对(增加了引号)
    重新定义对象描述,不能仅以名称储存信息,容易导致后续处理繁杂
    储存的数据结构需要重新拟定(每个语句依然是树,但储存语句直接用array)